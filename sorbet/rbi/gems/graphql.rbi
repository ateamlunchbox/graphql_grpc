# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/graphql/all/graphql.rbi
#
# graphql-1.9.6
module GraphQL
  def self.parse(graphql_string, tracer: nil); end
  def self.parse_file(filename); end
  def self.parse_with_racc(string, filename: nil, tracer: nil); end
  def self.scan(graphql_string); end
  def self.scan_with_ragel(graphql_string); end
end
class GraphQL::ExecutionError < GraphQL::Error
  def ast_node; end
  def ast_node=(arg0); end
  def extensions; end
  def extensions=(arg0); end
  def initialize(message, ast_node: nil, options: nil, extensions: nil); end
  def options; end
  def options=(arg0); end
  def path; end
  def path=(arg0); end
  def to_h; end
end
module GraphQL::Define
  def self.assign_metadata_key(key); end
end
module GraphQL::Define::AssignArgument
  def self.call(target, *args, **kwargs, &block); end
end
module GraphQL::Define::AssignConnection
  def self.call(type_defn, *field_args, max_page_size: nil, **field_kwargs, &field_block); end
end
module GraphQL::Define::AssignEnumValue
  def self.call(enum_type, name, desc = nil, deprecation_reason: nil, value: nil, &block); end
end
module GraphQL::Define::AssignGlobalIdField
  def self.call(type_defn, field_name); end
end
module GraphQL::Define::AssignMutationFunction
  def self.call(target, function); end
end
class GraphQL::Define::AssignMutationFunction::ResultProxy < SimpleDelegator
  def client_mutation_id; end
  def initialize(target, client_mutation_id); end
end
module GraphQL::Define::AssignObjectField
  def self.call(owner_type, name, type_or_field = nil, desc = nil, function: nil, field: nil, relay_mutation_function: nil, **kwargs, &block); end
end
class GraphQL::Define::DefinedObjectProxy
  def initialize(target); end
  def method_missing(name, *args, &block); end
  def respond_to_missing?(name, include_private = nil); end
  def target; end
  def types; end
  def use(plugin, **kwargs); end
end
module GraphQL::Define::InstanceDefinable
  def define(**kwargs, &block); end
  def ensure_defined; end
  def initialize_copy(other); end
  def metadata; end
  def redefine(**kwargs, &block); end
  def revive_dependent_methods; end
  def self.included(base); end
  def stash_dependent_methods; end
end
class GraphQL::Define::InstanceDefinable::Definition
  def define_keywords; end
  def define_proc; end
  def initialize(define_keywords, define_proc); end
end
module GraphQL::Define::InstanceDefinable::ClassMethods
  def accepts_definitions(*accepts); end
  def define(**kwargs, &block); end
  def dictionary; end
  def ensure_defined(*method_names); end
  def ensure_defined_method_names; end
  def own_dictionary; end
end
class GraphQL::Define::InstanceDefinable::AssignMetadataKey
  def call(defn, value = nil); end
  def initialize(key); end
end
class GraphQL::Define::InstanceDefinable::AssignAttribute
  def call(defn, value); end
  def initialize(attr_name); end
end
class GraphQL::Define::NoDefinitionError < GraphQL::Error
end
module GraphQL::Define::NonNullWithBang
  def !; end
end
class GraphQL::Define::TypeDefiner
  def Boolean; end
  def Float; end
  def ID; end
  def Int; end
  def String; end
  def [](type); end
  def self.allocate; end
  def self.instance; end
  def self.new(*arg0); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
module GraphQL::Relay
end
module GraphQL::Relay::TypeExtensions
  def connection_type; end
  def define_connection(**kwargs, &block); end
  def define_edge(**kwargs, &block); end
  def edge_type; end
end
class GraphQL::BaseType
  def ==(other); end
  def ast_node; end
  def ast_node=(arg0); end
  def coerce_input(value, ctx = nil); end
  def coerce_isolated_input(value); end
  def coerce_isolated_result(value); end
  def coerce_result(value, ctx); end
  def default_relay=(arg0); end
  def default_relay?; end
  def default_scalar=(arg0); end
  def default_scalar?; end
  def description; end
  def description=(arg0); end
  def get_field(name); end
  def graphql_definition; end
  def graphql_name; end
  def initialize; end
  def initialize_copy(other); end
  def inspect; end
  def introspection=(arg0); end
  def introspection?; end
  def list?; end
  def name; end
  def name=(name); end
  def non_null?; end
  def resolve_type(value, ctx); end
  def self.resolve_related_type(type_arg); end
  def to_definition(schema, printer: nil, **args); end
  def to_list_type; end
  def to_non_null_type; end
  def to_s; end
  def to_type_signature; end
  def unwrap; end
  def valid_input?(value, ctx = nil); end
  def valid_isolated_input?(value); end
  def validate_input(value, ctx = nil); end
  def validate_isolated_input(value); end
  def warn_deprecated_coerce(alt_method_name); end
  extend GraphQL::Define::InstanceDefinable::ClassMethods
  include GraphQL::Define::InstanceDefinable
  include GraphQL::Define::NonNullWithBang
  include GraphQL::Relay::TypeExtensions
end
module GraphQL::BaseType::ModifiesAnotherType
  def ==(other); end
  def unwrap; end
end
class GraphQL::ObjectType < GraphQL::BaseType
  def all_fields; end
  def dirty_inherited_interfaces; end
  def dirty_interfaces; end
  def fields; end
  def fields=(arg0); end
  def get_field(field_name); end
  def implements(interfaces, inherit: nil); end
  def initialize; end
  def initialize_copy(other); end
  def interface_fields; end
  def interfaces; end
  def interfaces=(new_interfaces); end
  def kind; end
  def load_interfaces; end
  def mutation; end
  def mutation=(arg0); end
  def normalize_interfaces(ifaces); end
  def relay_node_type; end
  def relay_node_type=(arg0); end
  def resolve_type_proc; end
end
class GraphQL::EnumType < GraphQL::BaseType
  def add_value(enum_value); end
  def ast_node; end
  def ast_node=(arg0); end
  def coerce_non_null_input(value_name, ctx); end
  def coerce_result(value, ctx = nil); end
  def initialize; end
  def initialize_copy(other); end
  def kind; end
  def to_s; end
  def validate_non_null_input(value_name, ctx); end
  def values; end
  def values=(new_values); end
end
class GraphQL::EnumType::EnumValue
  def ast_node; end
  def ast_node=(arg0); end
  def deprecation_reason; end
  def deprecation_reason=(arg0); end
  def description; end
  def description=(arg0); end
  def graphql_name; end
  def name; end
  def name=(new_name); end
  def value; end
  def value=(arg0); end
  extend GraphQL::Define::InstanceDefinable::ClassMethods
  include GraphQL::Define::InstanceDefinable
end
class GraphQL::EnumType::UnresolvedValueError < GraphQL::Error
end
class GraphQL::InputObjectType < GraphQL::BaseType
  def arguments; end
  def arguments=(arg0); end
  def arguments_class; end
  def arguments_class=(arg0); end
  def coerce_non_null_input(value, ctx); end
  def coerce_result(value, ctx = nil); end
  def initialize; end
  def initialize_copy(other); end
  def input_fields; end
  def kind; end
  def mutation; end
  def mutation=(arg0); end
  def validate_non_null_input(input, ctx); end
end
class GraphQL::InterfaceType < GraphQL::BaseType
  def all_fields; end
  def fields; end
  def fields=(arg0); end
  def get_field(field_name); end
  def get_possible_type(type_name, ctx); end
  def initialize; end
  def initialize_copy(other); end
  def kind; end
  def orphan_types; end
  def orphan_types=(arg0); end
  def possible_type?(type, ctx); end
  def resolve_type(value, ctx); end
  def resolve_type=(resolve_type_callable); end
  def resolve_type_proc; end
  def resolve_type_proc=(arg0); end
end
class GraphQL::ListType < GraphQL::BaseType
  def coerce_non_null_input(value, ctx); end
  def coerce_result(value, ctx = nil); end
  def ensure_array(value); end
  def initialize(of_type:); end
  def inspect; end
  def kind; end
  def list?; end
  def of_type; end
  def to_s; end
  def to_type_signature; end
  def validate_non_null_input(value, ctx); end
  include GraphQL::BaseType::ModifiesAnotherType
end
class GraphQL::DoubleNonNullTypeError < GraphQL::Error
end
class GraphQL::NonNullType < GraphQL::BaseType
  def coerce_input(*args, &block); end
  def coerce_result(*args, &block); end
  def initialize(of_type:); end
  def inspect; end
  def kind; end
  def list?(*args, &block); end
  def non_null?; end
  def of_type; end
  def to_s; end
  def to_type_signature; end
  def valid_input?(value, ctx); end
  def validate_input(value, ctx); end
  extend Forwardable
  include GraphQL::BaseType::ModifiesAnotherType
end
class GraphQL::UnionType < GraphQL::BaseType
  def dirty_possible_types; end
  def get_possible_type(type_name, ctx); end
  def include?(child_type_defn); end
  def initialize; end
  def initialize_copy(other); end
  def kind; end
  def possible_type?(type, ctx); end
  def possible_types; end
  def possible_types=(new_possible_types); end
  def resolve_type(value, ctx); end
  def resolve_type=(new_resolve_type_proc); end
  def resolve_type_proc; end
  def resolve_type_proc=(arg0); end
end
class GraphQL::Argument
  def as; end
  def as=(arg0); end
  def ast_node; end
  def ast_node=(arg0); end
  def default_value; end
  def default_value=(new_default_value); end
  def default_value?; end
  def description; end
  def description=(arg0); end
  def expose_as; end
  def graphql_name; end
  def initialize; end
  def initialize_copy(other); end
  def keyword; end
  def name; end
  def name=(arg0); end
  def prepare(value, ctx); end
  def prepare=(prepare_proc); end
  def self.deep_stringify(val); end
  def self.from_dsl(name, type_or_argument = nil, description = nil, default_value: nil, as: nil, prepare: nil, **kwargs, &block); end
  def type; end
  def type=(new_input_type); end
  extend GraphQL::Define::InstanceDefinable::ClassMethods
  include GraphQL::Define::InstanceDefinable
end
module GraphQL::Argument::DefaultPrepare
  def self.call(value, ctx); end
end
class GraphQL::Field
  def arguments; end
  def arguments=(arg0); end
  def arguments_class; end
  def arguments_class=(arg0); end
  def ast_node; end
  def ast_node=(arg0); end
  def build_default_resolver; end
  def complexity; end
  def complexity=(arg0); end
  def connection=(arg0); end
  def connection?; end
  def connection_max_page_size; end
  def connection_max_page_size=(arg0); end
  def deprecation_reason; end
  def deprecation_reason=(arg0); end
  def description; end
  def description=(arg0); end
  def edge_class; end
  def edge_class=(arg0); end
  def edges?; end
  def function; end
  def function=(arg0); end
  def graphql_name; end
  def hash_key; end
  def hash_key=(new_hash_key); end
  def initialize; end
  def initialize_copy(other); end
  def introspection=(arg0); end
  def introspection?; end
  def lazy_resolve(obj, args, ctx); end
  def lazy_resolve=(new_lazy_resolve_proc); end
  def lazy_resolve_proc; end
  def mutation; end
  def mutation=(arg0); end
  def name; end
  def name=(new_name); end
  def prepare_lazy(obj, args, ctx); end
  def property; end
  def property=(new_property); end
  def relay_node_field; end
  def relay_node_field=(arg0); end
  def relay_nodes_field; end
  def relay_nodes_field=(arg0); end
  def resolve(object, arguments, context); end
  def resolve=(new_resolve_proc); end
  def resolve_proc; end
  def subscription_scope; end
  def subscription_scope=(arg0); end
  def to_s; end
  def trace; end
  def trace=(arg0); end
  def type; end
  def type=(new_return_type); end
  extend GraphQL::Define::InstanceDefinable::ClassMethods
  include GraphQL::Define::InstanceDefinable
end
module GraphQL::Field::Resolve
  def create_proc(field); end
  def self.create_proc(field); end
end
class GraphQL::Field::Resolve::BuiltInResolve
end
class GraphQL::Field::Resolve::MethodResolve < GraphQL::Field::Resolve::BuiltInResolve
  def call(obj, args, ctx); end
  def initialize(field); end
end
class GraphQL::Field::Resolve::HashKeyResolve < GraphQL::Field::Resolve::BuiltInResolve
  def call(obj, args, ctx); end
  def initialize(hash_key); end
end
class GraphQL::Field::Resolve::NameResolve < GraphQL::Field::Resolve::BuiltInResolve
  def call(obj, args, ctx); end
  def initialize(field); end
end
module GraphQL::Field::DefaultLazyResolve
  def self.call(obj, args, ctx); end
end
module GraphQL::TypeKinds
end
class GraphQL::TypeKinds::TypeKind
  def abstract?; end
  def composite?; end
  def description; end
  def enum?; end
  def fields?; end
  def initialize(name, abstract: nil, fields: nil, wraps: nil, input: nil, description: nil); end
  def input?; end
  def input_object?; end
  def interface?; end
  def list?; end
  def name; end
  def non_null?; end
  def object?; end
  def resolves?; end
  def scalar?; end
  def to_s; end
  def union?; end
  def wraps?; end
end
module GraphQL::BackwardsCompatibility
  def get_arity(callable); end
  def self.get_arity(callable); end
  def self.wrap_arity(callable, from:, to:, name:, last: nil); end
  def wrap_arity(callable, from:, to:, name:, last: nil); end
end
class GraphQL::BackwardsCompatibility::FirstArgumentsWrapper
  def call(*args); end
  def initialize(callable, old_arity); end
end
class GraphQL::BackwardsCompatibility::LastArgumentsWrapper < GraphQL::BackwardsCompatibility::FirstArgumentsWrapper
  def call(*args); end
end
class GraphQL::ScalarType < GraphQL::BaseType
  def coerce=(proc); end
  def coerce_input=(coerce_input_fn); end
  def coerce_non_null_input(value, ctx); end
  def coerce_result(value, ctx = nil); end
  def coerce_result=(coerce_result_fn); end
  def ensure_two_arg(callable, method_name); end
  def initialize; end
  def kind; end
  def raw_coercion_input(value); end
  def validate_non_null_input(value, ctx); end
end
module GraphQL::ScalarType::NoOpCoerce
  def self.call(val, ctx); end
end
class GraphQL::NameValidator
  def self.valid?(name); end
  def self.validate!(name); end
end
module GraphQL::Language
  def self.serialize(value); end
end
module GraphQL::Language::BlockString
  def self.break_line(line, length); end
  def self.print(str, indent: nil); end
  def self.trim_whitespace(str); end
end
class GraphQL::Language::Printer
  def node; end
  def print(node, indent: nil); end
  def print_argument(argument); end
  def print_arguments(arguments, indent: nil); end
  def print_description(node, indent: nil, first_in_block: nil); end
  def print_directive(directive); end
  def print_directive_definition(directive); end
  def print_directives(directives); end
  def print_document(document); end
  def print_enum(enum); end
  def print_enum_type_definition(enum_type); end
  def print_enum_value_definition(enum_value); end
  def print_field(field, indent: nil); end
  def print_field_definition(field); end
  def print_field_definitions(fields); end
  def print_fragment_definition(fragment_def, indent: nil); end
  def print_fragment_spread(fragment_spread, indent: nil); end
  def print_inline_fragment(inline_fragment, indent: nil); end
  def print_input_object(input_object); end
  def print_input_object_type_definition(input_object_type); end
  def print_input_value_definition(input_value); end
  def print_interface_type_definition(interface_type); end
  def print_list_type(list_type); end
  def print_node(node, indent: nil); end
  def print_non_null_type(non_null_type); end
  def print_null_value; end
  def print_object_type_definition(object_type); end
  def print_operation_definition(operation_definition, indent: nil); end
  def print_scalar_type_definition(scalar_type); end
  def print_schema_definition(schema); end
  def print_selections(selections, indent: nil); end
  def print_type_name(type_name); end
  def print_union_type_definition(union_type); end
  def print_variable_definition(variable_definition); end
  def print_variable_identifier(variable_identifier); end
end
module GraphQL::Language::DefinitionSlice
  def find_definition_dependencies(definitions, name); end
  def slice(document, name); end
  extend GraphQL::Language::DefinitionSlice
end
class GraphQL::Language::DocumentFromSchemaDefinition
  def always_include_schema; end
  def build_argument_node(argument); end
  def build_argument_nodes(arguments); end
  def build_default_value(default_value, type); end
  def build_definition_nodes; end
  def build_directive_location_node(location); end
  def build_directive_location_nodes(locations); end
  def build_directive_node(directive); end
  def build_directive_nodes(directives); end
  def build_enum_type_node(enum_type); end
  def build_enum_value_node(enum_value); end
  def build_field_node(field); end
  def build_field_nodes(fields); end
  def build_input_object_node(input_object); end
  def build_interface_type_node(interface_type); end
  def build_object_type_node(object_type); end
  def build_scalar_type_node(scalar_type); end
  def build_schema_node; end
  def build_type_definition_node(type); end
  def build_type_definition_nodes(types); end
  def build_type_name_node(type); end
  def build_union_type_node(union_type); end
  def document; end
  def include_built_in_directives; end
  def include_built_in_scalars; end
  def include_introspection_types; end
  def include_schema_node?; end
  def initialize(schema, context: nil, only: nil, except: nil, include_introspection_types: nil, include_built_in_directives: nil, include_built_in_scalars: nil, always_include_schema: nil); end
  def schema; end
  def schema_respects_root_name_conventions?(schema); end
  def warden; end
end
module GraphQL::Language::Generation
  def generate(node, indent: nil, printer: nil); end
  extend GraphQL::Language::Generation
end
module GraphQL::Language::Lexer
  def self._graphql_lexer_char_class; end
  def self._graphql_lexer_char_class=(arg0); end
  def self._graphql_lexer_cond_actions; end
  def self._graphql_lexer_cond_actions=(arg0); end
  def self._graphql_lexer_cond_targs; end
  def self._graphql_lexer_cond_targs=(arg0); end
  def self._graphql_lexer_eof_trans; end
  def self._graphql_lexer_eof_trans=(arg0); end
  def self._graphql_lexer_from_state_actions; end
  def self._graphql_lexer_from_state_actions=(arg0); end
  def self._graphql_lexer_index_defaults; end
  def self._graphql_lexer_index_defaults=(arg0); end
  def self._graphql_lexer_index_offsets; end
  def self._graphql_lexer_index_offsets=(arg0); end
  def self._graphql_lexer_indicies; end
  def self._graphql_lexer_indicies=(arg0); end
  def self._graphql_lexer_nfa_offsets; end
  def self._graphql_lexer_nfa_offsets=(arg0); end
  def self._graphql_lexer_nfa_pop_trans; end
  def self._graphql_lexer_nfa_pop_trans=(arg0); end
  def self._graphql_lexer_nfa_push_actions; end
  def self._graphql_lexer_nfa_push_actions=(arg0); end
  def self._graphql_lexer_nfa_targs; end
  def self._graphql_lexer_nfa_targs=(arg0); end
  def self._graphql_lexer_to_state_actions; end
  def self._graphql_lexer_to_state_actions=(arg0); end
  def self._graphql_lexer_trans_cond_spaces; end
  def self._graphql_lexer_trans_cond_spaces=(arg0); end
  def self._graphql_lexer_trans_keys; end
  def self._graphql_lexer_trans_keys=(arg0); end
  def self.emit(token_name, ts, te, meta); end
  def self.emit_string(ts, te, meta, block:); end
  def self.graphql_lexer_en_main; end
  def self.graphql_lexer_en_main=(arg0); end
  def self.graphql_lexer_error; end
  def self.graphql_lexer_error=(arg0); end
  def self.graphql_lexer_first_final; end
  def self.graphql_lexer_first_final=(arg0); end
  def self.graphql_lexer_start; end
  def self.graphql_lexer_start=(arg0); end
  def self.record_comment(ts, te, meta); end
  def self.replace_escaped_characters_in_place(raw_string); end
  def self.run_lexer(query_string); end
  def self.tokenize(query_string); end
end
module GraphQL::Language::Nodes
end
class GraphQL::Language::Nodes::AbstractNode
  def children; end
  def col; end
  def delete_child(previous_child); end
  def eql?(other); end
  def filename; end
  def initialize(options = nil); end
  def initialize_copy(other); end
  def line; end
  def merge(new_options); end
  def position; end
  def replace_child(previous_child, new_child); end
  def scalars; end
  def self.children_methods(children_of_type); end
  def self.generate_initialize_node; end
  def self.inherited(child_class); end
  def self.scalar_methods(*method_names); end
  def to_query_string(printer: nil); end
  def visit_method; end
end
module GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def definition_line; end
  def initialize(options = nil); end
end
class GraphQL::Language::Nodes::WrapperType < GraphQL::Language::Nodes::AbstractNode
  def children_method_name; end
  def initialize_node(of_type: nil); end
  def of_type; end
  def scalars; end
  def visit_method; end
end
class GraphQL::Language::Nodes::NameOnlyNode < GraphQL::Language::Nodes::AbstractNode
  def children_method_name; end
  def initialize_node(name: nil); end
  def name; end
  def scalars; end
  def visit_method; end
end
class GraphQL::Language::Nodes::Argument < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def initialize_node(name: nil, value: nil); end
  def name; end
  def scalars; end
  def value; end
  def visit_method; end
end
class GraphQL::Language::Nodes::Directive < GraphQL::Language::Nodes::AbstractNode
  def arguments; end
  def children; end
  def children_method_name; end
  def initialize_node(name: nil, arguments: nil); end
  def merge_argument(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end
end
class GraphQL::Language::Nodes::DirectiveLocation < GraphQL::Language::Nodes::NameOnlyNode
  def children_method_name; end
  def visit_method; end
end
class GraphQL::Language::Nodes::DirectiveDefinition < GraphQL::Language::Nodes::AbstractNode
  def arguments; end
  def children; end
  def children_method_name; end
  def description; end
  def initialize_node(name: nil, description: nil, locations: nil, arguments: nil); end
  def locations; end
  def merge_argument(node_opts); end
  def merge_location(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end
  include GraphQL::Language::Nodes::AbstractNode::DefinitionNode
end
class GraphQL::Language::Nodes::Document < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def definitions; end
  def initialize_node(definitions: nil); end
  def slice_definition(name); end
  def visit_method; end
end
class GraphQL::Language::Nodes::Enum < GraphQL::Language::Nodes::NameOnlyNode
  def children_method_name; end
  def visit_method; end
end
class GraphQL::Language::Nodes::NullValue < GraphQL::Language::Nodes::NameOnlyNode
  def children_method_name; end
  def visit_method; end
end
class GraphQL::Language::Nodes::Field < GraphQL::Language::Nodes::AbstractNode
  def alias; end
  def arguments; end
  def children; end
  def children_method_name; end
  def directives; end
  def initialize_node(name: nil, arguments: nil, directives: nil, selections: nil, **kwargs); end
  def merge_argument(node_opts); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def name; end
  def scalars; end
  def selections; end
  def visit_method; end
end
class GraphQL::Language::Nodes::FragmentDefinition < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def directives; end
  def initialize_node(name: nil, type: nil, directives: nil, selections: nil); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def name; end
  def scalars; end
  def selections; end
  def type; end
  def visit_method; end
end
class GraphQL::Language::Nodes::FragmentSpread < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def directives; end
  def initialize_node(name: nil, directives: nil); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end
end
class GraphQL::Language::Nodes::InlineFragment < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def directives; end
  def initialize_node(type: nil, selections: nil, directives: nil); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def scalars; end
  def selections; end
  def type; end
  def visit_method; end
end
class GraphQL::Language::Nodes::InputObject < GraphQL::Language::Nodes::AbstractNode
  def arguments; end
  def children; end
  def children_method_name; end
  def initialize_node(arguments: nil); end
  def merge_argument(node_opts); end
  def serialize_value_for_hash(value); end
  def to_h(options = nil); end
  def visit_method; end
end
class GraphQL::Language::Nodes::ListType < GraphQL::Language::Nodes::WrapperType
  def children_method_name; end
  def visit_method; end
end
class GraphQL::Language::Nodes::NonNullType < GraphQL::Language::Nodes::WrapperType
  def children_method_name; end
  def visit_method; end
end
class GraphQL::Language::Nodes::VariableDefinition < GraphQL::Language::Nodes::AbstractNode
  def children_method_name; end
  def default_value; end
  def initialize_node(name: nil, type: nil, default_value: nil); end
  def name; end
  def scalars; end
  def type; end
  def visit_method; end
end
class GraphQL::Language::Nodes::OperationDefinition < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def directives; end
  def initialize_node(operation_type: nil, name: nil, variables: nil, selections: nil, directives: nil); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def merge_variable(node_opts); end
  def name; end
  def operation_type; end
  def scalars; end
  def selections; end
  def variables; end
  def visit_method; end
end
class GraphQL::Language::Nodes::TypeName < GraphQL::Language::Nodes::NameOnlyNode
  def children_method_name; end
  def visit_method; end
end
class GraphQL::Language::Nodes::VariableIdentifier < GraphQL::Language::Nodes::NameOnlyNode
  def children_method_name; end
  def visit_method; end
end
class GraphQL::Language::Nodes::SchemaDefinition < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def directives; end
  def initialize_node(query: nil, mutation: nil, subscription: nil, directives: nil); end
  def merge_directive(node_opts); end
  def mutation; end
  def query; end
  def scalars; end
  def subscription; end
  def visit_method; end
  include GraphQL::Language::Nodes::AbstractNode::DefinitionNode
end
class GraphQL::Language::Nodes::SchemaExtension < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def directives; end
  def initialize_node(query: nil, mutation: nil, subscription: nil, directives: nil); end
  def merge_directive(node_opts); end
  def mutation; end
  def query; end
  def scalars; end
  def subscription; end
  def visit_method; end
end
class GraphQL::Language::Nodes::ScalarTypeDefinition < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def description; end
  def directives; end
  def initialize_node(name: nil, description: nil, directives: nil); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end
  include GraphQL::Language::Nodes::AbstractNode::DefinitionNode
end
class GraphQL::Language::Nodes::ScalarTypeExtension < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def directives; end
  def initialize_node(name: nil, directives: nil); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end
end
class GraphQL::Language::Nodes::InputValueDefinition < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def default_value; end
  def description; end
  def directives; end
  def initialize_node(name: nil, type: nil, default_value: nil, description: nil, directives: nil); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def type; end
  def visit_method; end
  include GraphQL::Language::Nodes::AbstractNode::DefinitionNode
end
class GraphQL::Language::Nodes::FieldDefinition < GraphQL::Language::Nodes::AbstractNode
  def arguments; end
  def children; end
  def children_method_name; end
  def description; end
  def directives; end
  def fields; end
  def initialize_node(name: nil, type: nil, description: nil, directives: nil, arguments: nil); end
  def merge(new_options); end
  def merge_argument(node_opts); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def type; end
  def visit_method; end
  include GraphQL::Language::Nodes::AbstractNode::DefinitionNode
end
class GraphQL::Language::Nodes::ObjectTypeDefinition < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def description; end
  def directives; end
  def fields; end
  def initialize_node(name: nil, interfaces: nil, description: nil, directives: nil, fields: nil); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end
  include GraphQL::Language::Nodes::AbstractNode::DefinitionNode
end
class GraphQL::Language::Nodes::ObjectTypeExtension < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def directives; end
  def fields; end
  def initialize_node(name: nil, interfaces: nil, directives: nil, fields: nil); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end
end
class GraphQL::Language::Nodes::InterfaceTypeDefinition < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def description; end
  def directives; end
  def fields; end
  def initialize_node(name: nil, description: nil, directives: nil, fields: nil); end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end
  include GraphQL::Language::Nodes::AbstractNode::DefinitionNode
end
class GraphQL::Language::Nodes::InterfaceTypeExtension < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def directives; end
  def fields; end
  def initialize_node(name: nil, directives: nil, fields: nil); end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end
end
class GraphQL::Language::Nodes::UnionTypeDefinition < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def description; end
  def directives; end
  def initialize_node(name: nil, types: nil, description: nil, directives: nil); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def types; end
  def visit_method; end
  include GraphQL::Language::Nodes::AbstractNode::DefinitionNode
end
class GraphQL::Language::Nodes::UnionTypeExtension < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def directives; end
  def initialize_node(name: nil, types: nil, directives: nil); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def types; end
  def visit_method; end
end
class GraphQL::Language::Nodes::EnumValueDefinition < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def description; end
  def directives; end
  def initialize_node(name: nil, description: nil, directives: nil); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end
  include GraphQL::Language::Nodes::AbstractNode::DefinitionNode
end
class GraphQL::Language::Nodes::EnumTypeDefinition < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def description; end
  def directives; end
  def initialize_node(name: nil, description: nil, directives: nil, values: nil); end
  def merge_directive(node_opts); end
  def merge_value(node_opts); end
  def name; end
  def scalars; end
  def values; end
  def visit_method; end
  include GraphQL::Language::Nodes::AbstractNode::DefinitionNode
end
class GraphQL::Language::Nodes::EnumTypeExtension < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def directives; end
  def initialize_node(name: nil, directives: nil, values: nil); end
  def merge_directive(node_opts); end
  def merge_value(node_opts); end
  def name; end
  def scalars; end
  def values; end
  def visit_method; end
end
class GraphQL::Language::Nodes::InputObjectTypeDefinition < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def description; end
  def directives; end
  def fields; end
  def initialize_node(name: nil, description: nil, directives: nil, fields: nil); end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end
  include GraphQL::Language::Nodes::AbstractNode::DefinitionNode
end
class GraphQL::Language::Nodes::InputObjectTypeExtension < GraphQL::Language::Nodes::AbstractNode
  def children; end
  def children_method_name; end
  def directives; end
  def fields; end
  def initialize_node(name: nil, directives: nil, fields: nil); end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end
end
class GraphQL::Language::Parser < Racc::Parser
  def _reduce_10(val, _values, result); end
  def _reduce_101(val, _values, result); end
  def _reduce_102(val, _values, result); end
  def _reduce_103(val, _values, result); end
  def _reduce_104(val, _values, result); end
  def _reduce_105(val, _values, result); end
  def _reduce_106(val, _values, result); end
  def _reduce_107(val, _values, result); end
  def _reduce_108(val, _values, result); end
  def _reduce_11(val, _values, result); end
  def _reduce_113(val, _values, result); end
  def _reduce_115(val, _values, result); end
  def _reduce_116(val, _values, result); end
  def _reduce_12(val, _values, result); end
  def _reduce_125(val, _values, result); end
  def _reduce_126(val, _values, result); end
  def _reduce_133(val, _values, result); end
  def _reduce_134(val, _values, result); end
  def _reduce_135(val, _values, result); end
  def _reduce_136(val, _values, result); end
  def _reduce_137(val, _values, result); end
  def _reduce_138(val, _values, result); end
  def _reduce_139(val, _values, result); end
  def _reduce_140(val, _values, result); end
  def _reduce_141(val, _values, result); end
  def _reduce_142(val, _values, result); end
  def _reduce_143(val, _values, result); end
  def _reduce_144(val, _values, result); end
  def _reduce_145(val, _values, result); end
  def _reduce_149(val, _values, result); end
  def _reduce_150(val, _values, result); end
  def _reduce_151(val, _values, result); end
  def _reduce_153(val, _values, result); end
  def _reduce_154(val, _values, result); end
  def _reduce_155(val, _values, result); end
  def _reduce_156(val, _values, result); end
  def _reduce_157(val, _values, result); end
  def _reduce_158(val, _values, result); end
  def _reduce_159(val, _values, result); end
  def _reduce_16(val, _values, result); end
  def _reduce_160(val, _values, result); end
  def _reduce_161(val, _values, result); end
  def _reduce_162(val, _values, result); end
  def _reduce_163(val, _values, result); end
  def _reduce_164(val, _values, result); end
  def _reduce_165(val, _values, result); end
  def _reduce_166(val, _values, result); end
  def _reduce_167(val, _values, result); end
  def _reduce_168(val, _values, result); end
  def _reduce_169(val, _values, result); end
  def _reduce_170(val, _values, result); end
  def _reduce_171(val, _values, result); end
  def _reduce_172(val, _values, result); end
  def _reduce_173(val, _values, result); end
  def _reduce_174(val, _values, result); end
  def _reduce_175(val, _values, result); end
  def _reduce_176(val, _values, result); end
  def _reduce_177(val, _values, result); end
  def _reduce_18(val, _values, result); end
  def _reduce_19(val, _values, result); end
  def _reduce_2(val, _values, result); end
  def _reduce_20(val, _values, result); end
  def _reduce_21(val, _values, result); end
  def _reduce_22(val, _values, result); end
  def _reduce_23(val, _values, result); end
  def _reduce_24(val, _values, result); end
  def _reduce_25(val, _values, result); end
  def _reduce_26(val, _values, result); end
  def _reduce_27(val, _values, result); end
  def _reduce_28(val, _values, result); end
  def _reduce_29(val, _values, result); end
  def _reduce_3(val, _values, result); end
  def _reduce_30(val, _values, result); end
  def _reduce_31(val, _values, result); end
  def _reduce_32(val, _values, result); end
  def _reduce_36(val, _values, result); end
  def _reduce_37(val, _values, result); end
  def _reduce_4(val, _values, result); end
  def _reduce_60(val, _values, result); end
  def _reduce_61(val, _values, result); end
  def _reduce_62(val, _values, result); end
  def _reduce_63(val, _values, result); end
  def _reduce_64(val, _values, result); end
  def _reduce_65(val, _values, result); end
  def _reduce_66(val, _values, result); end
  def _reduce_67(val, _values, result); end
  def _reduce_68(val, _values, result); end
  def _reduce_69(val, _values, result); end
  def _reduce_70(val, _values, result); end
  def _reduce_71(val, _values, result); end
  def _reduce_72(val, _values, result); end
  def _reduce_73(val, _values, result); end
  def _reduce_82(val, _values, result); end
  def _reduce_83(val, _values, result); end
  def _reduce_84(val, _values, result); end
  def _reduce_85(val, _values, result); end
  def _reduce_86(val, _values, result); end
  def _reduce_87(val, _values, result); end
  def _reduce_88(val, _values, result); end
  def _reduce_89(val, _values, result); end
  def _reduce_90(val, _values, result); end
  def _reduce_91(val, _values, result); end
  def _reduce_92(val, _values, result); end
  def _reduce_93(val, _values, result); end
  def _reduce_94(val, _values, result); end
  def _reduce_95(val, _values, result); end
  def _reduce_96(val, _values, result); end
  def _reduce_97(val, _values, result); end
  def _reduce_98(val, _values, result); end
  def _reduce_99(val, _values, result); end
  def _reduce_none(val, _values, result); end
  def get_description(token); end
  def initialize(query_string, filename:, tracer: nil); end
  def make_node(node_name, assigns); end
  def next_token; end
  def on_error(parser_token_id, lexer_token, vstack); end
  def parse_document; end
  def self.parse(query_string, filename: nil, tracer: nil); end
end
class GraphQL::Language::Token
  def col; end
  def initialize(value:, name:, line:, col:, prev_token:); end
  def inspect; end
  def line; end
  def line_and_column; end
  def name; end
  def prev_token; end
  def to_f; end
  def to_i; end
  def to_s; end
  def value; end
end
class GraphQL::Language::Visitor
  def [](node_class); end
  def begin_visit(node, parent); end
  def end_visit(node, parent); end
  def initialize(document); end
  def on_abstract_node(node, parent); end
  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_directive_definition(node, parent); end
  def on_directive_location(node, parent); end
  def on_document(node, parent); end
  def on_enum(node, parent); end
  def on_enum_type_definition(node, parent); end
  def on_enum_type_extension(node, parent); end
  def on_enum_value_definition(node, parent); end
  def on_field(node, parent); end
  def on_field_definition(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_input_object(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_object_type_extension(node, parent); end
  def on_input_value_definition(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_interface_type_extension(node, parent); end
  def on_list_type(node, parent); end
  def on_node_with_modifications(node, parent); end
  def on_non_null_type(node, parent); end
  def on_null_value(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_object_type_extension(node, parent); end
  def on_operation_definition(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_scalar_type_extension(node, parent); end
  def on_schema_definition(node, parent); end
  def on_schema_extension(node, parent); end
  def on_type_name(node, parent); end
  def on_union_type_definition(node, parent); end
  def on_union_type_extension(node, parent); end
  def on_variable_definition(node, parent); end
  def on_variable_identifier(node, parent); end
  def result; end
  def self.apply_hooks(hooks, node, parent); end
  def self.make_visit_method(node_method); end
  def visit; end
  def visit_node(node, parent); end
end
class GraphQL::Language::Visitor::DeleteNode
end
class GraphQL::Language::Visitor::NodeVisitor
  def <<(hook); end
  def enter; end
  def initialize; end
  def leave; end
end
module GraphQL::Analysis
  def analysis_errors(results); end
  def analyze_multiplex(multiplex, analyzers); end
  def analyze_query(query, analyzers, multiplex_states: nil); end
  def reduce_node(irep_node, reducer_states); end
  def self.analysis_errors(results); end
  def self.analyze_multiplex(multiplex, analyzers); end
  def self.analyze_query(query, analyzers, multiplex_states: nil); end
  def self.reduce_node(irep_node, reducer_states); end
  def self.visit_analyzers(visit_type, irep_node, reducer_states); end
  def visit_analyzers(visit_type, irep_node, reducer_states); end
end
module GraphQL::Analysis::AST
  def analysis_errors(results); end
  def analyze_multiplex(multiplex, analyzers); end
  def analyze_query(query, analyzers, multiplex_analyzers: nil); end
  def self.analysis_errors(results); end
  def self.analyze_multiplex(multiplex, analyzers); end
  def self.analyze_query(query, analyzers, multiplex_analyzers: nil); end
  def self.use(schema_defn); end
  def use(schema_defn); end
end
class GraphQL::Analysis::AST::Visitor < GraphQL::Language::Visitor
  def argument_definition; end
  def arguments_for(ast_node, field_definition); end
  def call_analyzers(method, node, parent); end
  def directive_definition; end
  def enter_fragment_spread_inline(fragment_spread); end
  def field_definition; end
  def initialize(query:, analyzers:); end
  def leave_fragment_spread_inline(_fragment_spread); end
  def object_types; end
  def on_abstract_node(node, parent); end
  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_fragment_with_type(node); end
  def on_inline_fragment(node, parent); end
  def on_operation_definition(node, parent); end
  def parent_type_definition; end
  def previous_field_definition; end
  def query; end
  def response_path; end
  def skip?(ast_node); end
  def skipping?; end
  def type_definition; end
  def visit; end
  def visiting_fragment_definition?; end
end
class GraphQL::Analysis::AST::Analyzer
  def analyze?; end
  def initialize(query); end
  def on_enter_abstract_node(node, parent, visitor); end
  def on_enter_argument(node, parent, visitor); end
  def on_enter_directive(node, parent, visitor); end
  def on_enter_document(node, parent, visitor); end
  def on_enter_enum(node, parent, visitor); end
  def on_enter_field(node, parent, visitor); end
  def on_enter_fragment_spread(node, parent, visitor); end
  def on_enter_inline_fragment(node, parent, visitor); end
  def on_enter_input_object(node, parent, visitor); end
  def on_enter_list_type(node, parent, visitor); end
  def on_enter_non_null_type(node, parent, visitor); end
  def on_enter_null_value(node, parent, visitor); end
  def on_enter_operation_definition(node, parent, visitor); end
  def on_enter_type_name(node, parent, visitor); end
  def on_enter_variable_definition(node, parent, visitor); end
  def on_enter_variable_identifier(node, parent, visitor); end
  def on_leave_abstract_node(node, parent, visitor); end
  def on_leave_argument(node, parent, visitor); end
  def on_leave_directive(node, parent, visitor); end
  def on_leave_document(node, parent, visitor); end
  def on_leave_enum(node, parent, visitor); end
  def on_leave_field(node, parent, visitor); end
  def on_leave_fragment_spread(node, parent, visitor); end
  def on_leave_inline_fragment(node, parent, visitor); end
  def on_leave_input_object(node, parent, visitor); end
  def on_leave_list_type(node, parent, visitor); end
  def on_leave_non_null_type(node, parent, visitor); end
  def on_leave_null_value(node, parent, visitor); end
  def on_leave_operation_definition(node, parent, visitor); end
  def on_leave_type_name(node, parent, visitor); end
  def on_leave_variable_definition(node, parent, visitor); end
  def on_leave_variable_identifier(node, parent, visitor); end
  def query; end
  def result; end
  def self.build_visitor_hooks(member_name); end
end
class GraphQL::Analysis::AST::FieldUsage < GraphQL::Analysis::AST::Analyzer
  def initialize(query); end
  def on_leave_field(node, parent, visitor); end
  def result; end
end
class GraphQL::Analysis::AST::QueryComplexity < GraphQL::Analysis::AST::Analyzer
  def get_complexity(ast_node, field_defn, child_complexity, visitor); end
  def initialize(query); end
  def max_possible_complexity; end
  def on_enter_field(node, parent, visitor); end
  def on_enter_fragment_spread(node, _, visitor); end
  def on_leave_field(node, parent, visitor); end
  def on_leave_fragment_spread(node, _, visitor); end
  def result; end
  def selection_key(response_path, query); end
end
class GraphQL::Analysis::AST::QueryComplexity::TypeComplexity
  def initialize; end
  def max_possible_complexity; end
  def merge(type_defn, key, complexity); end
end
class GraphQL::Analysis::AST::MaxQueryComplexity < GraphQL::Analysis::AST::QueryComplexity
  def result; end
end
class GraphQL::Analysis::AST::QueryDepth < GraphQL::Analysis::AST::Analyzer
  def initialize(query); end
  def on_enter_field(node, parent, visitor); end
  def on_enter_fragment_spread(node, _, visitor); end
  def on_leave_field(node, parent, visitor); end
  def on_leave_fragment_spread(node, _, visitor); end
  def result; end
end
class GraphQL::Analysis::AST::MaxQueryDepth < GraphQL::Analysis::AST::QueryDepth
  def result; end
end
class GraphQL::Analysis::QueryComplexity
  def call(memo, visit_type, irep_node); end
  def final_value(reduced_value); end
  def get_complexity(irep_node, child_complexity); end
  def initial_value(target); end
  def initialize(&block); end
end
class GraphQL::Analysis::QueryComplexity::TypeComplexity
  def initialize; end
  def max_possible_complexity; end
  def merge(type_defn, complexity); end
end
class GraphQL::Analysis::MaxQueryComplexity < GraphQL::Analysis::QueryComplexity
  def initialize(max_complexity); end
end
class GraphQL::Analysis::QueryDepth
  def call(memo, visit_type, irep_node); end
  def final_value(memo); end
  def initial_value(query); end
  def initialize(&block); end
end
class GraphQL::Analysis::MaxQueryDepth < GraphQL::Analysis::QueryDepth
  def initialize(max_depth); end
end
class GraphQL::Analysis::ReducerState
  def call(visit_type, irep_node); end
  def errors; end
  def errors=(arg0); end
  def finalize_reducer; end
  def initialize(reducer, query); end
  def initialize_reducer(reducer, query); end
  def memo; end
  def memo=(arg0); end
  def reducer; end
end
class GraphQL::Analysis::FieldUsage
  def call(memo, visit_type, irep_node); end
  def final_value(memo); end
  def initial_value(query); end
  def initialize(&block); end
end
module GraphQL::Tracing
  def self.install(tracer); end
  def self.tracers; end
  def self.uninstall(tracer); end
end
module GraphQL::Tracing::ActiveSupportNotificationsTracing
  def self.trace(key, metadata); end
end
class GraphQL::Tracing::PlatformTracing
  def initialize(options = nil); end
  def instrument(type, field); end
  def options; end
  def self.platform_keys; end
  def self.platform_keys=(arg0); end
  def self.use(schema_defn, options = nil); end
  def trace(key, data); end
  def trace_field(type, field); end
end
class GraphQL::Tracing::AppsignalTracing < GraphQL::Tracing::PlatformTracing
  def platform_field_key(type, field); end
  def platform_trace(platform_key, key, data); end
end
class GraphQL::Tracing::DataDogTracing < GraphQL::Tracing::PlatformTracing
  def analytics_available?; end
  def analytics_enabled?; end
  def analytics_sample_rate; end
  def platform_field_key(type, field); end
  def platform_trace(platform_key, key, data); end
  def service_name; end
  def tracer; end
end
class GraphQL::Tracing::NewRelicTracing < GraphQL::Tracing::PlatformTracing
  def initialize(options = nil); end
  def platform_field_key(type, field); end
  def platform_trace(platform_key, key, data); end
end
class GraphQL::Tracing::ScoutTracing < GraphQL::Tracing::PlatformTracing
  def initialize(options = nil); end
  def platform_field_key(type, field); end
  def platform_trace(platform_key, key, data); end
end
class GraphQL::Tracing::SkylightTracing < GraphQL::Tracing::PlatformTracing
  def initialize(options = nil); end
  def platform_field_key(type, field); end
  def platform_trace(platform_key, key, data); end
end
class GraphQL::Tracing::PrometheusTracing < GraphQL::Tracing::PlatformTracing
  def initialize(opts = nil); end
  def instrument_execution(platform_key, key, data, &block); end
  def observe(platform_key, key, duration); end
  def platform_field_key(type, field); end
  def platform_trace(platform_key, key, data, &block); end
end
module GraphQL::Tracing::Traceable
  def call_tracers(idx, key, metadata); end
  def trace(key, metadata); end
end
module GraphQL::Tracing::NullTracer
  def self.trace(k, v); end
  def trace(k, v); end
end
module GraphQL::Execution
end
module GraphQL::Execution::DirectiveChecks
  def include?(directive_ast_nodes, query); end
  def self.include?(directive_ast_nodes, query); end
end
class GraphQL::Execution::Execute
  def execute(ast_operation, root_type, query); end
  def self.begin_multiplex(_multiplex); end
  def self.begin_query(query, _multiplex); end
  def self.finish_multiplex(results, multiplex); end
  def self.finish_query(query, _multiplex); end
  include GraphQL::Execution::Execute::ExecutionFunctions
end
class GraphQL::Execution::Execute::Skip
end
class GraphQL::Execution::Execute::PropagateNull
end
module GraphQL::Execution::Execute::ExecutionFunctions
  def continue_or_wait(raw_value, field_type, field_ctx); end
  def continue_resolve_field(raw_value, field_type, field_ctx); end
  def lazy_resolve_root_selection(result, query: nil, multiplex: nil); end
  def resolve_field(object, field_ctx); end
  def resolve_root_selection(query); end
  def resolve_selection(object, current_type, current_ctx, mutation: nil); end
  def resolve_value(value, field_type, field_ctx); end
  def self.continue_or_wait(raw_value, field_type, field_ctx); end
  def self.continue_resolve_field(raw_value, field_type, field_ctx); end
  def self.lazy_resolve_root_selection(result, query: nil, multiplex: nil); end
  def self.resolve_field(object, field_ctx); end
  def self.resolve_root_selection(query); end
  def self.resolve_selection(object, current_type, current_ctx, mutation: nil); end
  def self.resolve_value(value, field_type, field_ctx); end
end
module GraphQL::Execution::Execute::FieldResolveStep
  def self.call(_parent_type, parent_object, field_definition, field_args, context, _next = nil); end
end
module GraphQL::Execution::Flatten
  def self.call(ctx); end
  def self.flatten(obj); end
end
module GraphQL::Execution::Instrumentation
  def self.apply_instrumenters(multiplex); end
  def self.call_after_hooks(instrumenters, object, after_hook_name, ex); end
  def self.call_hooks(instrumenters, object, before_hook_name, after_hook_name); end
  def self.each_query_call_hooks(instrumenters, queries, i = nil); end
end
class GraphQL::Execution::Interpreter
  def evaluate(query); end
  def execute(_operation, _root_type, query); end
  def initialize; end
  def self.begin_multiplex(multiplex); end
  def self.begin_query(query, multiplex); end
  def self.finish_multiplex(_results, multiplex); end
  def self.finish_query(query, _multiplex); end
  def self.use(schema_defn); end
  def sync_lazies(query: nil, multiplex: nil); end
end
class GraphQL::Execution::Interpreter::ExecutionErrors
  def add(err_or_msg); end
  def initialize(ctx, ast_node, path); end
end
class GraphQL::Execution::Interpreter::HashResponse
  def final_value; end
  def initialize; end
  def inspect; end
  def write(path, value); end
end
class GraphQL::Execution::Interpreter::Runtime
  def add_dead_path(path); end
  def after_lazy(obj, owner:, field:, path:, eager: nil); end
  def arg_to_value(graphql_object, arg_type, ast_value); end
  def arguments(graphql_object, arg_owner, ast_node_or_hash); end
  def context; end
  def continue_field(path, value, field, type, ast_node, next_selections, is_non_null); end
  def continue_value(path, value, field, is_non_null, ast_node); end
  def dead_path?(path); end
  def directives_include?(node, graphql_object, parent_type); end
  def each_argument_pair(ast_args_or_hash); end
  def evaluate_selections(path, owner_object, owner_type, selections, root_operation_type: nil); end
  def final_value; end
  def flatten_ast_value(v); end
  def gather_selections(owner_object, owner_type, selections, selections_by_name); end
  def initialize(query:, response:); end
  def inspect; end
  def query; end
  def resolve_if_late_bound_type(type); end
  def resolve_with_directives(object, ast_node); end
  def run_directive(object, ast_node, idx); end
  def run_eager; end
  def schema; end
  def set_type_at_path(path, type); end
  def type_at(path); end
  def write_execution_errors_in_response(path, errors); end
  def write_in_response(path, value); end
  def write_invalid_null_in_response(path, invalid_null_error); end
end
module GraphQL::Execution::Interpreter::Resolve
  def self.resolve(results); end
  def self.resolve_all(results); end
end
class GraphQL::Execution::Lazy
  def field; end
  def initialize(path: nil, field: nil, &get_value_func); end
  def path; end
  def self.all(lazies); end
  def self.resolve(val); end
  def then; end
  def value; end
end
class GraphQL::Execution::Lazy::LazyMethodMap
  def find_superclass_method(value_class); end
  def get(value); end
  def initialize(use_concurrent: nil); end
  def initialize_copy(other); end
  def set(lazy_class, lazy_value_method); end
  def storage; end
end
class GraphQL::Execution::Lazy::LazyMethodMap::ConcurrentishMap
  def []=(key, value); end
  def compute_if_absent(key); end
  def copy_storage; end
  def each_pair(*args, &block); end
  def initialize; end
  def initialize_copy(other); end
  def size(*args, &block); end
  extend Forwardable
end
module GraphQL::Execution::Lazy::Resolve
  def self.deep_sync(val); end
  def self.each_lazy(acc, value); end
  def self.resolve(value); end
  def self.resolve_in_place(value); end
end
module GraphQL::Execution::Lazy::Resolve::NullAccumulator
  def self.<<(item); end
  def self.empty?; end
end
class GraphQL::Execution::Lookahead
  def arguments; end
  def arguments_match?(arguments, field_defn, field_node); end
  def ast_nodes; end
  def field; end
  def find_selected_nodes(node, field_name, field_defn, arguments:, matches:); end
  def find_selections(subselections_by_type, selections_on_type, selected_type, ast_selections, arguments); end
  def initialize(query:, ast_nodes:, field: nil, root_type: nil, owner_type: nil); end
  def inspect; end
  def name; end
  def normalize_keyword(keyword); end
  def normalize_name(name); end
  def owner_type; end
  def selected?; end
  def selection(field_name, selected_type: nil, arguments: nil); end
  def selections(arguments: nil); end
  def selects?(field_name, arguments: nil); end
end
class GraphQL::Execution::Lookahead::NullLookahead < GraphQL::Execution::Lookahead
  def initialize; end
  def inspect; end
  def selected?; end
  def selection(*arg0); end
  def selections(*arg0); end
  def selects?(*arg0); end
end
module GraphQL::Execution::Lookahead::ArgumentHelpers
  def arg_to_value(query, graphql_object, arg_type, ast_value); end
  def arguments(query, graphql_object, arg_owner, ast_node); end
  def flatten_ast_value(query, v); end
  def self.arg_to_value(query, graphql_object, arg_type, ast_value); end
  def self.arguments(query, graphql_object, arg_owner, ast_node); end
  def self.flatten_ast_value(query, v); end
end
module GraphQL::Execution::Lookahead::FieldHelpers
  def get_field(schema, owner_type, field_name); end
  def self.get_field(schema, owner_type, field_name); end
end
class GraphQL::Execution::Multiplex
  def context; end
  def initialize(schema:, queries:, context:, max_complexity:); end
  def max_complexity; end
  def queries; end
  def schema; end
  def self.begin_query(query, multiplex); end
  def self.finish_query(data_result, query, multiplex); end
  def self.instrument_and_analyze(multiplex); end
  def self.run_all(schema, query_options, *args); end
  def self.run_as_multiplex(multiplex); end
  def self.run_one_legacy(schema, query); end
  def self.run_queries(schema, queries, context: nil, max_complexity: nil); end
  def self.supports_multiplexing?(schema); end
  include GraphQL::Tracing::Traceable
end
module GraphQL::Execution::Typecast
  def self.subtype?(parent_type, child_type); end
end
module GraphQL::Dig
  def dig(own_key, *rest_keys); end
end
module Base64Bp
  def self.urlsafe_decode64(str); end
  def self.urlsafe_encode64(bin, padding:); end
  def urlsafe_decode64(str); end
  def urlsafe_encode64(bin, padding:); end
  extend Base64
end
class GraphQL::Schema
  def _schema_class; end
  def accessible?(*args, &block); end
  def after_lazy(value); end
  def analysis_engine; end
  def analysis_engine=(arg0); end
  def as_json(only: nil, except: nil, context: nil); end
  def ast_node; end
  def ast_node=(arg0); end
  def authorized?(*args, &block); end
  def check_resolved_type(type, object, ctx = nil); end
  def context_class; end
  def context_class=(arg0); end
  def cursor_encoder; end
  def cursor_encoder=(arg0); end
  def default_filter; end
  def default_mask; end
  def default_mask=(arg0); end
  def default_max_page_size; end
  def default_max_page_size=(arg0); end
  def define(**kwargs, &block); end
  def directive(*args, &block); end
  def directives; end
  def directives=(arg0); end
  def error_bubbling; end
  def error_bubbling=(arg0); end
  def execute(query_str = nil, **kwargs); end
  def execution_strategy_for_operation(operation); end
  def find(path); end
  def get_field(parent_type, field_name); end
  def get_fields(type); end
  def graphql_definition; end
  def id_from_object(object, type, ctx); end
  def id_from_object=(new_proc); end
  def id_from_object_proc; end
  def inaccessible_fields(*args, &block); end
  def initialize; end
  def initialize_copy(other); end
  def inspect; end
  def instrument(instrumentation_type, instrumenter); end
  def instrumenters; end
  def instrumenters=(arg0); end
  def interpreter=(arg0); end
  def interpreter?; end
  def introspection_namespace; end
  def introspection_namespace=(arg0); end
  def introspection_system; end
  def lazy?(obj); end
  def lazy_method_name(obj); end
  def lazy_methods; end
  def lazy_methods=(arg0); end
  def max_complexity; end
  def max_complexity=(arg0); end
  def max_depth; end
  def max_depth=(arg0); end
  def middleware; end
  def middleware=(arg0); end
  def multiplex(queries, **kwargs); end
  def multiplex_analyzers; end
  def multiplex_analyzers=(arg0); end
  def mutation; end
  def mutation=(arg0); end
  def mutation_execution_strategy; end
  def mutation_execution_strategy=(arg0); end
  def object_from_id(id, ctx); end
  def object_from_id=(new_proc); end
  def object_from_id_proc; end
  def orphan_types; end
  def orphan_types=(arg0); end
  def parse_error(err, ctx); end
  def parse_error=(new_proc); end
  def possible_types(type_defn); end
  def query; end
  def query=(arg0); end
  def query_analyzers; end
  def query_analyzers=(arg0); end
  def query_execution_strategy; end
  def query_execution_strategy=(arg0); end
  def raise_definition_error; end
  def raise_definition_error=(arg0); end
  def rebuild_artifacts; end
  def references_to(type_name); end
  def remove_handler(*args, &block); end
  def rescue_from(*args, &block); end
  def rescue_middleware; end
  def rescues?; end
  def resolve_type(type, object, ctx = nil); end
  def resolve_type=(new_resolve_type_proc); end
  def resolve_type_proc; end
  def root_type_for_operation(operation); end
  def root_types; end
  def self.accessible?(member, context); end
  def self.after_lazy(*args, &block); end
  def self.analysis_engine(*args, &block); end
  def self.analysis_engine=(*args, &block); end
  def self.as_json(*args, &block); end
  def self.call_on_type_class(member, method_name, *args, default:); end
  def self.context_class(new_context_class = nil); end
  def self.cursor_encoder(new_encoder = nil); end
  def self.default_directives; end
  def self.default_execution_strategy; end
  def self.default_execution_strategy=(arg0); end
  def self.default_filter(*args, &block); end
  def self.default_mask(*args, &block); end
  def self.default_max_page_size(new_default_max_page_size = nil); end
  def self.defined_instrumenters; end
  def self.defined_middleware; end
  def self.defined_multiplex_analyzers; end
  def self.defined_query_analyzers; end
  def self.defined_tracers; end
  def self.directive(new_directive); end
  def self.directives(new_directives = nil); end
  def self.error_bubbling(new_error_bubbling = nil); end
  def self.error_bubbling=(*args, &block); end
  def self.execute(*args, &block); end
  def self.execution_strategy_for_operation(*args, &block); end
  def self.find(*args, &block); end
  def self.from_definition(definition_or_path, default_resolve: nil, parser: nil); end
  def self.from_introspection(introspection_result); end
  def self.get_field(*args, &block); end
  def self.get_fields(*args, &block); end
  def self.graphql_definition; end
  def self.id_from_object(object, type, ctx); end
  def self.id_from_object=(*args, &block); end
  def self.id_from_object_proc(*args, &block); end
  def self.inaccessible_fields(error); end
  def self.inherited(child_class); end
  def self.instrument(instrument_step, instrumenter, options = nil); end
  def self.instrumenters(*args, &block); end
  def self.interpreter?(*args, &block); end
  def self.introspection(new_introspection_namespace = nil); end
  def self.introspection_system(*args, &block); end
  def self.lazy?(*args, &block); end
  def self.lazy_classes; end
  def self.lazy_method_name(*args, &block); end
  def self.lazy_resolve(lazy_class, value_method); end
  def self.max_complexity(max_complexity = nil); end
  def self.max_complexity=(*args, &block); end
  def self.max_depth(new_max_depth = nil); end
  def self.max_depth=(*args, &block); end
  def self.metadata(*args, &block); end
  def self.middleware(new_middleware = nil); end
  def self.multiplex(*args, &block); end
  def self.multiplex_analyzer(new_analyzer); end
  def self.multiplex_analyzers(*args, &block); end
  def self.mutation(new_mutation_object = nil); end
  def self.mutation_execution_strategy(new_mutation_execution_strategy = nil); end
  def self.object_from_id(node_id, ctx); end
  def self.object_from_id=(*args, &block); end
  def self.object_from_id_proc(*args, &block); end
  def self.orphan_types(*new_orphan_types); end
  def self.plugins; end
  def self.possible_types(*args, &block); end
  def self.query(new_query_object = nil); end
  def self.query_analyzer(new_analyzer); end
  def self.query_analyzers(*args, &block); end
  def self.query_execution_strategy(new_query_execution_strategy = nil); end
  def self.redefine(*args, &block); end
  def self.references_to(*args, &block); end
  def self.remove_handler(*args, &block); end
  def self.rescue_from(*err_classes, &handler_block); end
  def self.resolve_type(type, obj, ctx); end
  def self.root_type_for_operation(*args, &block); end
  def self.root_types(*args, &block); end
  def self.static_validator(*args, &block); end
  def self.subscription(new_subscription_object = nil); end
  def self.subscription_execution_strategy(new_subscription_execution_strategy = nil); end
  def self.subscriptions(*args, &block); end
  def self.sync_lazy(value); end
  def self.to_definition(*args, &block); end
  def self.to_document(*args, &block); end
  def self.to_graphql; end
  def self.to_json(*args, &block); end
  def self.tracer(new_tracer); end
  def self.tracers(*args, &block); end
  def self.type_error(type_err, ctx); end
  def self.type_from_ast(*args, &block); end
  def self.types(*args, &block); end
  def self.unauthorized_field(unauthorized_error); end
  def self.unauthorized_object(unauthorized_error); end
  def self.union_memberships(*args, &block); end
  def self.use(plugin, options = nil); end
  def self.using_ast_analysis?(*args, &block); end
  def self.validate(*args, &block); end
  def self.visible?(member, context); end
  def static_validator; end
  def subscription; end
  def subscription=(arg0); end
  def subscription_execution_strategy; end
  def subscription_execution_strategy=(arg0); end
  def subscriptions; end
  def subscriptions=(arg0); end
  def sync_lazy(value); end
  def to_definition(only: nil, except: nil, context: nil); end
  def to_document; end
  def to_json(*args); end
  def tracers; end
  def type_error(err, ctx); end
  def type_error=(new_proc); end
  def type_from_ast(ast_node); end
  def types; end
  def unauthorized_field(*args, &block); end
  def unauthorized_object(*args, &block); end
  def union_memberships(type); end
  def using_ast_analysis?; end
  def validate(string_or_document, rules: nil, context: nil); end
  def visible?(*args, &block); end
  def with_definition_error_check; end
  extend Forwardable
  extend GraphQL::Define::InstanceDefinable::ClassMethods
  extend GraphQL::Schema::Member::AcceptsDefinition
  extend GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  include GraphQL::Define::InstanceDefinable
end
module GraphQL::Schema::Base64Encoder
  def self.decode(encoded_text, nonce: nil); end
  def self.encode(unencoded_text, nonce: nil); end
end
module GraphQL::Schema::CatchallMiddleware
  def self.call(parent_type, parent_object, field_definition, field_args, query_context); end
end
module GraphQL::Schema::DefaultParseError
  def self.call(parse_error, ctx); end
end
module GraphQL::Schema::DefaultTypeError
  def self.call(type_error, ctx); end
end
class GraphQL::Schema::Finder
  def find(path); end
  def find_in_directive(directive, path:); end
  def find_in_enum_type(enum_type, path:); end
  def find_in_field(field, path:); end
  def find_in_fields_type(type, kind:, path:); end
  def find_in_input_object(input_object, path:); end
  def find_in_type(type, path:); end
  def initialize(schema); end
  def schema; end
end
class GraphQL::Schema::Finder::MemberNotFoundError < ArgumentError
end
class GraphQL::Schema::InvalidTypeError < GraphQL::Error
end
class GraphQL::Schema::IntrospectionSystem
  def dynamic_field(name:); end
  def dynamic_fields; end
  def entry_point(name:); end
  def entry_points; end
  def get_fields_from_class(class_sym:); end
  def initialize(schema); end
  def load_constant(class_name); end
  def object_types; end
  def schema_type; end
  def type_type; end
  def typename_field; end
end
class GraphQL::Schema::IntrospectionSystem::PerFieldProxyResolve
  def call(obj, args, ctx); end
  def initialize(object_class:, inner_resolve:); end
end
class GraphQL::Schema::LateBoundType
  def initialize(local_name); end
  def inspect; end
  def name; end
  def to_list_type; end
  def to_non_null_type; end
  def to_s; end
  def unwrap; end
end
class GraphQL::Schema::MiddlewareChain
  def <<(callable); end
  def ==(other); end
  def [](*args, &block); end
  def add_middleware(callable); end
  def concat(callables); end
  def delete(*args, &block); end
  def final_step; end
  def first(*args, &block); end
  def initialize(steps: nil, final_step: nil); end
  def initialize_copy(other); end
  def insert(*args, &block); end
  def invoke(arguments); end
  def invoke_core(index, arguments); end
  def push(callable); end
  def steps; end
  def wrap(callable); end
  extend Forwardable
end
class GraphQL::Schema::MiddlewareChain::MiddlewareWrapper
  def call(*args, &next_middleware); end
  def callable; end
  def initialize(callable); end
end
module GraphQL::Schema::NullMask
  def self.call(member, ctx); end
end
class GraphQL::Schema::PossibleTypes
  def initialize(schema); end
  def possible_types(type_defn); end
end
class GraphQL::Schema::RescueMiddleware
  def attempt_rescue(err); end
  def call(*args); end
  def initialize; end
  def remove_handler(*error_classes); end
  def rescue_from(*error_classes, &block); end
  def rescue_table; end
end
class GraphQL::Schema::TimeoutMiddleware
  def call(parent_type, parent_object, field_definition, field_args, query_context); end
  def initialize(max_seconds:, context_key: nil, &block); end
  def on_timeout(parent_type, parent_object, field_definition, field_args, field_context); end
end
class GraphQL::Schema::TimeoutMiddleware::TimeoutQueryProxy < SimpleDelegator
  def context; end
  def initialize(query, ctx); end
end
class GraphQL::Schema::TimeoutMiddleware::TimeoutError < GraphQL::ExecutionError
  def initialize(parent_type, field_defn); end
end
class GraphQL::Schema::Traversal
  def initialize(schema, introspection: nil); end
  def instrumented_field_map; end
  def resolve_late_bound_fields; end
  def rewrap_resolved_type(late_bound_type, resolved_inner_type); end
  def type_map; end
  def type_reference_map; end
  def union_memberships; end
  def validate_type(member, context_description); end
  def visit(schema, member, context_description); end
  def visit_field_on_type(schema, type_defn, field_defn, dynamic_field: nil); end
  def visit_fields(schema, type_defn); end
end
module GraphQL::Schema::TypeExpression
  def self.build_type(types, ast_node); end
  def self.wrap_type(type, wrapper); end
end
module GraphQL::Schema::UniqueWithinType
  def decode(node_id, separator: nil); end
  def encode(type_name, object_value, separator: nil); end
  def self.decode(node_id, separator: nil); end
  def self.default_id_separator; end
  def self.default_id_separator=(arg0); end
  def self.encode(type_name, object_value, separator: nil); end
end
class GraphQL::Schema::Validation
  def self.validate(object); end
end
module GraphQL::Schema::Validation::Rules
  def self.assert_named_items_are_valid(item_name, get_items_proc); end
  def self.assert_property(property_name, *allowed_classes); end
  def self.assert_property_list_of(property_name, list_member_class); end
  def self.assert_property_mapping(property_name, from_class, to_class); end
end
class GraphQL::Schema::Warden
  def arguments(argument_owner); end
  def directives; end
  def enum_values(enum_defn); end
  def fields(type_defn); end
  def get_field(parent_type, field_name); end
  def get_type(type_name); end
  def initialize(filter, context:, schema:); end
  def interfaces(obj_type); end
  def orphan_type?(type_defn); end
  def possible_types(type_defn); end
  def read_through; end
  def referenced?(type_defn); end
  def root_type?(type_defn); end
  def root_type_for_operation(op_name); end
  def types; end
  def union_memberships(obj_type); end
  def visible?(member); end
  def visible_abstract_type?(type_defn); end
  def visible_field?(field_defn); end
  def visible_possible_types?(type_defn); end
  def visible_type?(type_defn); end
end
module GraphQL::Schema::BuildFromDefinition
  def self.from_definition(definition_string, default_resolve:, parser: nil); end
end
class GraphQL::Schema::BuildFromDefinition::ResolveMap
  def call(type, field, obj, args, ctx); end
  def coerce_input(type, value, ctx); end
  def coerce_result(type, value, ctx); end
  def initialize(user_resolve_hash); end
end
class GraphQL::Schema::BuildFromDefinition::ResolveMap::DefaultResolve
  def call(obj, args, ctx); end
  def initialize(field_map, field_name); end
end
module GraphQL::Schema::BuildFromDefinition::DefaultResolve
  def self.call(type, field, obj, args, ctx); end
end
module GraphQL::Schema::BuildFromDefinition::Builder
  def build(document, default_resolve: nil); end
  def build_default_value(default_value); end
  def build_deprecation_reason(directives); end
  def build_directive(directive_definition, type_resolver); end
  def build_directive_arguments(directive_definition, type_resolver); end
  def build_enum_type(enum_type_definition, type_resolver); end
  def build_fields(field_definitions, type_resolver, default_resolve:); end
  def build_input_arguments(input_object_type_definition, type_resolver); end
  def build_input_object_type(input_object_type_definition, type_resolver); end
  def build_interface_type(interface_type_definition, type_resolver); end
  def build_object_type(object_type_definition, type_resolver, default_resolve:); end
  def build_scalar_type(scalar_type_definition, type_resolver, default_resolve:); end
  def build_union_type(union_type_definition, type_resolver); end
  def resolve_type(types, ast_node); end
  def resolve_type_name(type); end
  extend GraphQL::Schema::BuildFromDefinition::Builder
end
class GraphQL::Schema::Member
  extend GraphQL::Relay::TypeExtensions
  extend GraphQL::Schema::Member::BaseDSLMethods
  extend GraphQL::Schema::Member::CachedGraphQLDefinition
  extend GraphQL::Schema::Member::HasPath
  extend GraphQL::Schema::Member::RelayShortcuts
  extend GraphQL::Schema::Member::Scoped
  extend GraphQL::Schema::Member::TypeSystemHelpers
  include GraphQL::Schema::Member::GraphQLTypeNames
end
module GraphQL::Schema::Member::AcceptsDefinition
  def self.extended(child); end
  def self.included(child); end
end
module GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  def accepts_definition(name); end
  def accepts_definition_methods; end
  def own_accepts_definition_methods; end
end
module GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def to_graphql; end
end
module GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  def accepts_definition_methods; end
  def initialize(*args, **kwargs, &block); end
end
module GraphQL::Schema::Member::BaseDSLMethods
  def accessible?(context); end
  def authorized?(object, context); end
  def default_graphql_name; end
  def description(new_description = nil); end
  def find_inherited_method(method_name, default_value); end
  def graphql_name(new_name = nil); end
  def introspection(new_introspection = nil); end
  def introspection?; end
  def mutation(mutation_class = nil); end
  def name(new_name = nil); end
  def overridden_graphql_name; end
  def to_graphql; end
  def unwrap; end
  def visible?(context); end
end
module GraphQL::Schema::Member::CachedGraphQLDefinition
  def graphql_definition; end
  def initialize_copy(original); end
end
module GraphQL::Schema::Member::GraphQLTypeNames
end
module GraphQL::Schema::Member::HasPath
  def path; end
end
module GraphQL::Schema::Member::RelayShortcuts
  def connection_type; end
  def connection_type_class(new_connection_type_class = nil); end
  def edge_type; end
  def edge_type_class(new_edge_type_class = nil); end
end
module GraphQL::Schema::Member::Scoped
  def scope_items(items, context); end
end
module GraphQL::Schema::Member::TypeSystemHelpers
  def kind; end
  def list?; end
  def non_null?; end
  def to_list_type; end
  def to_non_null_type; end
  def to_type_signature; end
end
module GraphQL::Schema::Member::HasArguments
  def add_argument(arg_defn); end
  def argument(*args, **kwargs, &block); end
  def argument_class(new_arg_class = nil); end
  def argument_with_loads(name, type, *rest, loads: nil, **kwargs); end
  def arguments; end
  def own_arguments; end
  def self.extended(cls); end
  def self.included(cls); end
end
module GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  def argument_class(new_arg_class = nil); end
end
module GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  def load_application_object(argument, lookup_as_type, id); end
  def load_application_object_failed(err); end
  def object_from_id(type, id, context); end
end
module GraphQL::Schema::Member::HasFields
  def add_field(field_defn); end
  def field(*args, **kwargs, &block); end
  def field_class(new_field_class = nil); end
  def fields; end
  def get_field(field_name); end
  def global_id_field(field_name); end
  def own_fields; end
end
module GraphQL::Schema::Member::Instrumentation
  def after_query(_query); end
  def apply_proxy(field); end
  def before_query(query); end
  def instrument(type, field); end
  def list_depth(type, starting_at = nil); end
  def self.after_query(_query); end
  def self.apply_proxy(field); end
  def self.before_query(query); end
  def self.instrument(type, field); end
  def self.list_depth(type, starting_at = nil); end
end
class GraphQL::Schema::Member::Instrumentation::ProxiedResolve
  def call(obj, args, ctx); end
  def initialize(inner_resolve:, list_depth:, inner_return_type:); end
  def proxy_to_depth(inner_obj, depth, ctx); end
end
module GraphQL::Schema::Member::BuildType
  def camelize(string); end
  def constantize(string); end
  def parse_type(type_expr, null:); end
  def self.camelize(string); end
  def self.constantize(string); end
  def self.parse_type(type_expr, null:); end
  def self.to_type_name(something); end
  def self.underscore(string); end
  def to_type_name(something); end
  def underscore(string); end
end
class GraphQL::Schema::Wrapper
  def ==(other); end
  def initialize(of_type); end
  def of_type; end
  def to_graphql; end
  def unwrap; end
  include GraphQL::Schema::Member::CachedGraphQLDefinition
  include GraphQL::Schema::Member::TypeSystemHelpers
end
class GraphQL::Schema::List < GraphQL::Schema::Wrapper
  def kind; end
  def list?; end
  def to_graphql; end
  def to_type_signature; end
end
class GraphQL::Schema::NonNull < GraphQL::Schema::Wrapper
  def inspect; end
  def kind; end
  def list?; end
  def non_null?; end
  def to_graphql; end
  def to_type_signature; end
end
class GraphQL::Schema::Argument
  def accessible?(context); end
  def authorized?(obj, ctx); end
  def default_value; end
  def default_value?; end
  def description(text = nil); end
  def description=(arg0); end
  def graphql_name; end
  def initialize(*args, **kwargs, &block); end
  def keyword; end
  def name; end
  def owner; end
  def prepare; end
  def prepare_value(obj, value); end
  def to_graphql; end
  def type; end
  def visible?(context); end
  extend GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  include GraphQL::Schema::Member::AcceptsDefinition
  include GraphQL::Schema::Member::CachedGraphQLDefinition
  include GraphQL::Schema::Member::HasPath
end
class GraphQL::Schema::EnumValue < GraphQL::Schema::Member
  def accessible?(_ctx); end
  def authorized?(_ctx); end
  def deprecation_reason; end
  def deprecation_reason=(arg0); end
  def description(new_desc = nil); end
  def graphql_name; end
  def initialize(*args, **kwargs, &block); end
  def owner; end
  def to_graphql; end
  def value(new_val = nil); end
  def visible?(_ctx); end
  extend GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  include GraphQL::Schema::Member::AcceptsDefinition
  include GraphQL::Schema::Member::HasPath
end
class GraphQL::Schema::Enum < GraphQL::Schema::Member
  def self.coerce_input(*args, &block); end
  def self.coerce_isolated_input(*args, &block); end
  def self.coerce_isolated_result(*args, &block); end
  def self.coerce_result(*args, &block); end
  def self.enum_value_class(new_enum_value_class = nil); end
  def self.kind; end
  def self.own_values; end
  def self.to_graphql; end
  def self.value(*args, **kwargs, &block); end
  def self.values; end
  extend GraphQL::Schema::Member::AcceptsDefinition
  extend GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end
class GraphQL::Schema::FieldExtension
  def after_resolve(object:, arguments:, context:, value:, memo:); end
  def apply; end
  def field; end
  def initialize(field:, options:); end
  def options; end
  def resolve(object:, arguments:, context:); end
end
class GraphQL::Schema::Field
  def accessible?(context); end
  def authorized?(object, context); end
  def complexity(new_complexity); end
  def connection?; end
  def deprecation_reason; end
  def deprecation_reason=(arg0); end
  def description(text = nil); end
  def description=(arg0); end
  def extension(extension, options = nil); end
  def extensions(new_extensions = nil); end
  def extras; end
  def fetch_extra(extra_name, ctx); end
  def graphql_name; end
  def initialize(*args, **kwargs, &block); end
  def max_page_size; end
  def method_str; end
  def method_sym; end
  def mutation; end
  def name; end
  def original_name; end
  def owner; end
  def public_send_field(obj, ruby_kwargs, field_ctx); end
  def resolve(object, args, ctx); end
  def resolve_field(obj, args, ctx); end
  def resolve_field_method(obj, ruby_kwargs, ctx); end
  def resolver; end
  def resolver_method; end
  def run_extensions_before_resolve(memos, obj, args, ctx, idx: nil); end
  def scoped?; end
  def self.from_options(name = nil, type = nil, desc = nil, resolver: nil, mutation: nil, subscription: nil, **kwargs, &block); end
  def subscription_scope; end
  def to_graphql; end
  def to_ruby_args(obj, graphql_args, field_ctx); end
  def trace; end
  def type; end
  def visible?(context); end
  def with_extensions(obj, args, ctx); end
  extend GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  include GraphQL::Schema::Member::AcceptsDefinition
  include GraphQL::Schema::Member::CachedGraphQLDefinition
  include GraphQL::Schema::Member::HasArguments
  include GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include GraphQL::Schema::Member::HasPath
end
class GraphQL::Schema::Field::ConnectionExtension < GraphQL::Schema::FieldExtension
  def after_resolve(value:, object:, arguments:, context:, memo:); end
  def apply; end
  def resolve(object:, arguments:, context:); end
end
class GraphQL::Schema::Field::ScopeExtension < GraphQL::Schema::FieldExtension
  def after_resolve(value:, context:, **rest); end
end
class GraphQL::Schema::InputObject < GraphQL::Schema::Member
  def [](key); end
  def any?(*args, &block); end
  def arguments; end
  def context; end
  def each(*args, &block); end
  def empty?(*args, &block); end
  def initialize(values = nil, context:, defaults_used:, ruby_kwargs: nil); end
  def key?(key); end
  def keys(*args, &block); end
  def map(*args, &block); end
  def self.argument(name, type, *rest, loads: nil, **kwargs, &block); end
  def self.arguments_class; end
  def self.arguments_class=(arg0); end
  def self.kind; end
  def self.to_graphql; end
  def to_h; end
  def to_kwargs; end
  def unwrap_value(value); end
  def values(*args, &block); end
  extend Forwardable
  extend GraphQL::Schema::Member::AcceptsDefinition
  extend GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend GraphQL::Schema::Member::HasArguments
  extend GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  include GraphQL::Dig
  include GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
end
module GraphQL::Schema::Interface
  def unwrap; end
  extend GraphQL::Schema::Interface::DefinitionMethods
  extend GraphQL::Schema::Member::AcceptsDefinition
  include GraphQL::Schema::Member::GraphQLTypeNames
end
module GraphQL::Schema::Interface::DefinitionMethods
  def accessible?(context); end
  def definition_methods(&block); end
  def included(child_class); end
  def interfaces; end
  def kind; end
  def orphan_types(*types); end
  def own_interfaces; end
  def to_graphql; end
  def visible?(context); end
  include GraphQL::Relay::TypeExtensions
  include GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  include GraphQL::Schema::Member::BaseDSLMethods
  include GraphQL::Schema::Member::CachedGraphQLDefinition
  include GraphQL::Schema::Member::HasFields
  include GraphQL::Schema::Member::HasPath
  include GraphQL::Schema::Member::RelayShortcuts
  include GraphQL::Schema::Member::Scoped
  include GraphQL::Schema::Member::TypeSystemHelpers
end
class GraphQL::Schema::Scalar < GraphQL::Schema::Member
  def self.coerce_input(val, ctx); end
  def self.coerce_isolated_input(*args, &block); end
  def self.coerce_isolated_result(*args, &block); end
  def self.coerce_result(val, ctx); end
  def self.default_scalar(is_default = nil); end
  def self.kind; end
  def self.to_graphql; end
  extend GraphQL::Schema::Member::AcceptsDefinition
  extend GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end
class GraphQL::Schema::Object < GraphQL::Schema::Member
  def context; end
  def initialize(object, context); end
  def object; end
  def self.authorized_new(object, context); end
  def self.fields; end
  def self.implements(*new_interfaces); end
  def self.interfaces; end
  def self.kind; end
  def self.new(*arg0); end
  def self.own_interfaces; end
  def self.to_graphql; end
  extend GraphQL::Schema::Member::AcceptsDefinition
  extend GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend GraphQL::Schema::Member::HasFields
end
class GraphQL::Schema::Union < GraphQL::Schema::Member
  def self.kind; end
  def self.possible_types(*types); end
  def self.to_graphql; end
  extend GraphQL::Schema::Member::AcceptsDefinition
  extend GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end
class GraphQL::Schema::Directive < GraphQL::Schema::Member
  def self.default_directive(new_default_directive = nil); end
  def self.default_graphql_name; end
  def self.include?(_object, _arguments, _context); end
  def self.locations(*new_locations); end
  def self.resolve(object, arguments, context); end
  def self.to_graphql; end
  extend GraphQL::Schema::Member::HasArguments
  extend GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  include GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
end
class GraphQL::Schema::Directive::Include < GraphQL::Schema::Directive
  def self.include?(obj, args, ctx); end
end
class GraphQL::Schema::Directive::Skip < GraphQL::Schema::Directive
  def self.include?(obj, args, ctx); end
end
class GraphQL::Schema::Directive::Feature < GraphQL::Schema::Directive
  def self.enabled?(flag_name, object, context); end
  def self.include?(object, arguments, context); end
end
class GraphQL::Schema::Directive::Transform < GraphQL::Schema::Directive
  def self.resolve(object, arguments, context); end
end
class GraphQL::Schema::Resolver
  def authorized?(**args); end
  def context; end
  def initialize(object:, context:); end
  def load_argument(name, value); end
  def load_arguments(args); end
  def object; end
  def ready?(**args); end
  def resolve(**args); end
  def resolve_with_support(**args); end
  def self.argument(name, type, *rest, loads: nil, **kwargs, &block); end
  def self.arguments_loads_as_type; end
  def self.complexity(new_complexity = nil); end
  def self.extras(new_extras = nil); end
  def self.field_options; end
  def self.null(allow_null = nil); end
  def self.own_arguments_loads_as_type; end
  def self.resolve_method(new_method = nil); end
  def self.type(new_type = nil, null: nil); end
  def self.type_expr; end
  extend GraphQL::Schema::Member::BaseDSLMethods
  extend GraphQL::Schema::Member::HasArguments
  extend GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend GraphQL::Schema::Member::HasPath
  include GraphQL::Schema::Member::GraphQLTypeNames
  include GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include GraphQL::Schema::Member::HasPath
end
module GraphQL::Schema::Resolver::HasPayloadType
  def field_class(new_class = nil); end
  def generate_payload_type; end
  def object_class(new_class = nil); end
  def payload_type(new_payload_type = nil); end
  def type(new_payload_type = nil); end
  def type_expr(new_payload_type = nil); end
end
class GraphQL::Schema::Mutation < GraphQL::Schema::Resolver
  def self.field(*args, &block); end
  def self.generate_payload_type; end
  def self.visible?(context); end
  extend GraphQL::Schema::Member::HasFields
  extend GraphQL::Schema::Resolver::HasPayloadType
end
module GraphQL::Types
end
class GraphQL::Types::String < GraphQL::Schema::Scalar
  def self.coerce_input(value, _ctx); end
  def self.coerce_result(value, ctx); end
end
class GraphQL::Schema::RelayClassicMutation < GraphQL::Schema::Mutation
  def resolve_with_support(**inputs); end
  def self.field_options; end
  def self.generate_input_type; end
  def self.input_object_class(new_class = nil); end
  def self.input_type(new_input_type = nil); end
end
class GraphQL::Schema::Subscription < GraphQL::Schema::Resolver
  def initialize(object:, context:); end
  def load_application_object_failed(err); end
  def resolve(**args); end
  def resolve_subscribe(args); end
  def resolve_update(args); end
  def subscribe(args = nil); end
  def unsubscribe; end
  def update(args = nil); end
  extend GraphQL::Schema::Member::HasFields
  extend GraphQL::Schema::Resolver::HasPayloadType
end
class GraphQL::Schema::Subscription::EarlyTerminationError < StandardError
end
class GraphQL::Schema::Subscription::UnsubscribedError < GraphQL::Schema::Subscription::EarlyTerminationError
end
class GraphQL::Schema::Subscription::NoUpdateError < GraphQL::Schema::Subscription::EarlyTerminationError
end
class GraphQL::Schema::InvalidDocumentError < GraphQL::Error
end
module GraphQL::Schema::MethodWrappers
  def resolve_type(type, obj, ctx = nil); end
end
class GraphQL::Schema::CyclicalDefinitionError < GraphQL::Error
end
class GraphQL::Directive
  def arguments; end
  def arguments=(arg0); end
  def arguments_class; end
  def arguments_class=(arg0); end
  def ast_node; end
  def ast_node=(arg0); end
  def default_directive=(arg0); end
  def default_directive?; end
  def description; end
  def description=(arg0); end
  def graphql_definition; end
  def graphql_name; end
  def initialize; end
  def inspect; end
  def locations; end
  def locations=(arg0); end
  def name; end
  def name=(arg0); end
  def on_field?; end
  def on_fragment?; end
  def on_operation?; end
  def to_s; end
  extend GraphQL::Define::InstanceDefinable::ClassMethods
  include GraphQL::Define::InstanceDefinable
end
class GraphQL::Types::Boolean < GraphQL::Schema::Scalar
  def self.coerce_input(value, _ctx); end
  def self.coerce_result(value, _ctx); end
end
class GraphQL::Types::BigInt < GraphQL::Schema::Scalar
  def self.coerce_input(value, _ctx); end
  def self.coerce_result(value, _ctx); end
end
class GraphQL::Types::Float < GraphQL::Schema::Scalar
  def self.coerce_input(value, _ctx); end
  def self.coerce_result(value, _ctx); end
end
class GraphQL::Types::ID < GraphQL::Schema::Scalar
  def self.coerce_input(value, _ctx); end
  def self.coerce_result(value, _ctx); end
end
class GraphQL::Types::Int < GraphQL::Schema::Scalar
  def self.coerce_input(value, _ctx); end
  def self.coerce_result(value, ctx); end
end
class GraphQL::Types::ISO8601DateTime < GraphQL::Schema::Scalar
  def self.coerce_input(str_value, _ctx); end
  def self.coerce_result(value, _ctx); end
  def self.time_precision; end
  def self.time_precision=(value); end
end
class GraphQL::Types::JSON < GraphQL::Schema::Scalar
  def self.coerce_input(value, _context); end
  def self.coerce_result(value, _context); end
end
module GraphQL::Types::Relay
end
class GraphQL::Types::Relay::BaseField < GraphQL::Schema::Field
  def initialize(edge_class: nil, **rest, &block); end
  def to_graphql; end
end
class GraphQL::Types::Relay::BaseObject < GraphQL::Schema::Object
  def self.default_relay(new_value); end
  def self.default_relay?; end
  def self.to_graphql; end
end
module GraphQL::Types::Relay::BaseInterface
  extend GraphQL::Schema::Interface::DefinitionMethods
  extend GraphQL::Schema::Interface::DefinitionMethods
  extend GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  include GraphQL::Schema::Interface
end
module GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  def default_relay(new_value); end
  def default_relay?; end
  def to_graphql; end
end
class GraphQL::Types::Relay::PageInfo < GraphQL::Types::Relay::BaseObject
end
class GraphQL::Types::Relay::BaseConnection < GraphQL::Types::Relay::BaseObject
  def cursor_from_node(*args, &block); end
  def edges; end
  def nodes; end
  def parent(*args, &block); end
  def self.accessible?(ctx); end
  def self.authorized?(obj, ctx); end
  def self.define_nodes_field; end
  def self.edge_class; end
  def self.edge_type(edge_type_class, edge_class: nil, node_type: nil, nodes_field: nil); end
  def self.node_type; end
  def self.nodes_field; end
  def self.scope_items(items, context); end
  def self.visible?(ctx); end
  extend Forwardable
end
class GraphQL::Types::Relay::BaseEdge < GraphQL::Types::Relay::BaseObject
  def self.accessible?(ctx); end
  def self.authorized?(obj, ctx); end
  def self.node_type(node_type = nil, null: nil); end
  def self.visible?(ctx); end
end
module GraphQL::Types::Relay::Node
  extend GraphQL::Schema::Interface::DefinitionMethods
  extend GraphQL::Schema::Interface::DefinitionMethods
  extend GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  extend GraphQL::Types::Relay::Node::DefinitionMethods
  include GraphQL::Types::Relay::BaseInterface
end
module GraphQL::Types::Relay::Node::DefinitionMethods
end
class GraphQL::Relay::Edge
  def connection; end
  def cursor; end
  def initialize(node, connection); end
  def inspect; end
  def node; end
  def parent; end
end
module GraphQL::Relay::EdgeType
  def self.create_type(wrapped_type, name: nil, &block); end
end
module GraphQL::Relay::EdgesInstrumentation
  def self.instrument(type, field); end
end
class GraphQL::Relay::EdgesInstrumentation::EdgesResolve
  def call(obj, args, ctx); end
  def initialize(edge_class:, resolve:); end
end
class GraphQL::Relay::BaseConnection
  def after; end
  def arguments; end
  def before; end
  def context; end
  def cursor_from_node(object); end
  def decode(data); end
  def edge_nodes; end
  def encode(data); end
  def end_cursor; end
  def field; end
  def first; end
  def get_limited_arg(arg_name); end
  def has_next_page; end
  def has_previous_page; end
  def initialize(nodes, arguments, field: nil, max_page_size: nil, parent: nil, context: nil); end
  def inspect; end
  def last; end
  def max_page_size; end
  def nodes; end
  def page_info; end
  def paged_nodes; end
  def parent; end
  def self.connection_for_nodes(nodes); end
  def self.register_connection_implementation(nodes_class, connection_class); end
  def sliced_nodes; end
  def start_cursor; end
end
class GraphQL::Relay::ArrayConnection < GraphQL::Relay::BaseConnection
  def cursor_from_node(item); end
  def first; end
  def has_next_page; end
  def has_previous_page; end
  def index_from_cursor(cursor); end
  def last; end
  def paged_nodes; end
  def sliced_nodes; end
end
class GraphQL::Relay::RangeAdd
  def connection; end
  def edge; end
  def initialize(collection:, item:, parent: nil, context: nil, edge_class: nil); end
  def parent; end
end
class GraphQL::Relay::RelationConnection < GraphQL::Relay::BaseConnection
  def cursor_from_node(item); end
  def first; end
  def has_next_page; end
  def has_previous_page; end
  def last; end
  def limit_nodes(sliced_nodes, limit); end
  def offset_from_cursor(cursor); end
  def paged_nodes; end
  def paged_nodes_offset; end
  def relation_count(relation); end
  def relation_limit(relation); end
  def relation_offset(relation); end
  def sliced_nodes; end
  def sliced_nodes_count; end
end
class GraphQL::Relay::MongoRelationConnection < GraphQL::Relay::RelationConnection
  def limit_nodes(sliced_nodes, limit); end
  def relation_count(relation); end
  def relation_limit(relation); end
  def relation_offset(relation); end
end
class GraphQL::Relay::GlobalIdResolve
  def call(obj, args, ctx); end
  def initialize(type:); end
end
class GraphQL::Relay::Mutation
  def arguments; end
  def arguments=(arg0); end
  def description; end
  def description=(arg0); end
  def field; end
  def fields; end
  def fields=(arg0); end
  def has_generated_return_type?; end
  def initialize; end
  def input_fields; end
  def input_type; end
  def name; end
  def name=(arg0); end
  def resolve=(new_resolve_proc); end
  def result_class; end
  def return_fields; end
  def return_interfaces; end
  def return_interfaces=(arg0); end
  def return_type; end
  def return_type=(arg0); end
  extend GraphQL::Define::InstanceDefinable::ClassMethods
  include GraphQL::Define::InstanceDefinable
end
module GraphQL::Relay::Mutation::Instrumentation
  def self.instrument(type, field); end
end
class GraphQL::Relay::Mutation::Resolve
  def build_result(mutation_result, args, ctx); end
  def call(obj, args, ctx); end
  def initialize(mutation, resolve); end
end
class GraphQL::Relay::Mutation::Result
  def client_mutation_id; end
  def initialize(client_mutation_id:, result:); end
  def self.define_subclass(mutation_defn); end
  def self.mutation; end
  def self.mutation=(arg0); end
end
module GraphQL::Relay::Node
  def self.field(**kwargs, &block); end
  def self.interface; end
  def self.plural_field(**kwargs, &block); end
end
module GraphQL::Relay::ConnectionInstrumentation
  def self.default_arguments; end
  def self.instrument(type, field); end
end
class GraphQL::Relay::ConnectionResolve
  def build_connection(nodes, args, parent, ctx); end
  def call(obj, args, ctx); end
  def initialize(field, underlying_resolve); end
end
module GraphQL::Relay::ConnectionType
  def self.bidirectional_pagination; end
  def self.bidirectional_pagination=(arg0); end
  def self.create_type(wrapped_type, edge_type: nil, edge_class: nil, nodes_field: nil, &block); end
  def self.default_nodes_field; end
  def self.default_nodes_field=(arg0); end
end
module GraphQL::Schema::Loader
  def load(introspection_result); end
  def self.define_type(type, type_resolver); end
  def self.extract_default_value(default_value_str, input_value_ast); end
  def self.resolve_type(types, type); end
  extend GraphQL::Schema::Loader
end
class GraphQL::Schema::Printer < GraphQL::Language::Printer
  def initialize(schema, context: nil, only: nil, except: nil, introspection: nil); end
  def print_directive(directive); end
  def print_schema; end
  def print_type(type); end
  def schema; end
  def self.print_introspection_schema; end
  def self.print_schema(schema, **args); end
  def warden; end
end
class GraphQL::Schema::Printer::IntrospectionPrinter < GraphQL::Language::Printer
  def print_schema_definition(schema); end
end
module GraphQL::Introspection
end
class GraphQL::Introspection::BaseObject < GraphQL::Schema::Object
  def self.field(*args, **kwargs, &block); end
  def self.inherited(child_class); end
end
class GraphQL::Introspection::InputValueType < GraphQL::Introspection::BaseObject
  def default_value; end
end
class GraphQL::Introspection::EnumValueType < GraphQL::Introspection::BaseObject
  def is_deprecated; end
  def name; end
end
class GraphQL::Introspection::TypeKindEnum < GraphQL::Schema::Enum
end
class GraphQL::Introspection::TypeType < GraphQL::Introspection::BaseObject
  def enum_values(include_deprecated:); end
  def fields(include_deprecated:); end
  def input_fields; end
  def interfaces; end
  def kind; end
  def name; end
  def of_type; end
  def possible_types; end
end
class GraphQL::Introspection::FieldType < GraphQL::Introspection::BaseObject
  def args; end
  def is_deprecated; end
end
class GraphQL::Introspection::DirectiveLocationEnum < GraphQL::Schema::Enum
end
class GraphQL::Introspection::DirectiveType < GraphQL::Introspection::BaseObject
  def args; end
end
class GraphQL::Introspection::SchemaType < GraphQL::Introspection::BaseObject
  def directives; end
  def mutation_type; end
  def permitted_root_type(op_type); end
  def query_type; end
  def subscription_type; end
  def types; end
end
class GraphQL::Introspection::DynamicFields < GraphQL::Introspection::BaseObject
  def __typename(irep_node: nil); end
end
class GraphQL::Introspection::EntryPoints < GraphQL::Introspection::BaseObject
  def __schema; end
  def __type(name:); end
end
class GraphQL::AnalysisError < GraphQL::ExecutionError
end
class GraphQL::CoercionError < GraphQL::Error
end
class GraphQL::LiteralValidationError < GraphQL::Error
  def ast_value; end
  def ast_value=(arg0); end
end
class GraphQL::RuntimeTypeError < GraphQL::Error
end
class GraphQL::InvalidNullError < GraphQL::RuntimeTypeError
  def field; end
  def initialize(parent_type, field, value); end
  def parent_error?; end
  def parent_type; end
  def to_h; end
  def value; end
end
class GraphQL::InvalidNameError < GraphQL::ExecutionError
  def initialize(name, valid_regex); end
  def name; end
  def valid_regex; end
end
class GraphQL::UnresolvedTypeError < GraphQL::RuntimeTypeError
  def field; end
  def initialize(value, field, parent_type, resolved_type, possible_types); end
  def parent_type; end
  def possible_types; end
  def resolved_type; end
  def value; end
end
class GraphQL::IntegerEncodingError < GraphQL::RuntimeTypeError
  def initialize(value); end
  def integer_value; end
end
class GraphQL::StringEncodingError < GraphQL::RuntimeTypeError
  def initialize(str); end
  def string; end
end
class GraphQL::Query
  def analysis_errors; end
  def analysis_errors=(arg0); end
  def analyzers(*args, &block); end
  def arguments_for(irep_or_ast_node, definition); end
  def ast_analyzers(*args, &block); end
  def context; end
  def document; end
  def find_operation(operations, operation_name); end
  def fragments; end
  def get_field(*args, &block); end
  def get_type(*args, &block); end
  def initialize(schema, query_string = nil, query: nil, document: nil, context: nil, variables: nil, validate: nil, subscription_topic: nil, operation_name: nil, root_value: nil, max_depth: nil, max_complexity: nil, except: nil, only: nil); end
  def inspect; end
  def internal_representation(*args, &block); end
  def interpreter?(*args, &block); end
  def irep_selection; end
  def lookahead; end
  def max_complexity(*args, &block); end
  def max_depth(*args, &block); end
  def merge_filters(only: nil, except: nil); end
  def mutation?; end
  def operation_name; end
  def operation_name=(arg0); end
  def operations; end
  def possible_types(*args, &block); end
  def prepare_ast; end
  def provided_variables; end
  def query?; end
  def query_string; end
  def query_string=(arg0); end
  def resolve_type(abstract_type, value = nil); end
  def result; end
  def result_values; end
  def result_values=(result_hash); end
  def root_type_for_operation(*args, &block); end
  def root_value; end
  def root_value=(arg0); end
  def schema; end
  def selected_operation; end
  def selected_operation_name; end
  def static_errors; end
  def subscription?; end
  def subscription_topic; end
  def subscription_update?; end
  def tracers; end
  def valid?; end
  def validate; end
  def validate=(arg0); end
  def validation_errors(*args, &block); end
  def validation_pipeline; end
  def variables; end
  def warden; end
  def with_prepared_ast; end
  extend Forwardable
  include GraphQL::Tracing::Traceable
end
class GraphQL::Query::Arguments
  def [](key); end
  def any?(*args, &block); end
  def argument_values; end
  def default_used?(key); end
  def each(*args, &block); end
  def each_value; end
  def initialize(values, context:, defaults_used:); end
  def key?(key); end
  def keys(*args, &block); end
  def self.argument_definitions; end
  def self.argument_definitions=(arg0); end
  def self.construct_arguments_class(argument_owner); end
  def to_h; end
  def to_kwargs; end
  def unwrap_value(value); end
  def values(*args, &block); end
  def wrap_value(value, arg_defn_type, context); end
  extend Forwardable
  include GraphQL::Dig
end
class GraphQL::Query::Arguments::NoArguments < GraphQL::Query::Arguments
end
class GraphQL::Query::Arguments::ArgumentValue
  def default_used=(arg0); end
  def default_used?; end
  def definition; end
  def initialize(key, value, definition, default_used); end
  def key; end
  def value; end
end
module GraphQL::Query::ArgumentsCache
  def self.build(query); end
end
class GraphQL::Query::Context
  def [](*args, &block); end
  def []=(*args, &block); end
  def ast_node; end
  def dig(*args, &block); end
  def errors; end
  def execution_strategy; end
  def execution_strategy=(new_strategy); end
  def fetch(*args, &block); end
  def initialize(query:, values:, object:); end
  def inspect; end
  def interpreter=(arg0); end
  def interpreter?(*args, &block); end
  def irep_node; end
  def key?(*args, &block); end
  def namespace(ns); end
  def path; end
  def query; end
  def received_null_child; end
  def schema; end
  def strategy; end
  def to_h(*args, &block); end
  def to_hash(*args, &block); end
  def trace(*args, &block); end
  def value=(arg0); end
  def warden; end
  extend Forwardable
  include GraphQL::Query::Context::SharedMethods
end
module GraphQL::Query::Context::SharedMethods
  def add_error(error); end
  def backtrace; end
  def delete(child_ctx); end
  def execution_errors; end
  def invalid_null?; end
  def lookahead; end
  def object; end
  def object=(arg0); end
  def skip; end
  def skipped; end
  def skipped=(arg0); end
  def skipped?; end
  def spawn_child(key:, irep_node:, object:); end
  def value; end
end
class GraphQL::Query::Context::ExecutionErrors
  def >>(err_or_msg); end
  def add(err_or_msg); end
  def initialize(ctx); end
  def push(err_or_msg); end
end
class GraphQL::Query::Context::FieldResolutionContext
  def [](*args, &block); end
  def []=(*args, &block); end
  def add_error(error); end
  def ast_node; end
  def dig(*args, &block); end
  def errors(*args, &block); end
  def execution_strategy(*args, &block); end
  def fetch(*args, &block); end
  def field; end
  def initialize(context, key, irep_node, parent, object); end
  def inspect; end
  def interpreter?(*args, &block); end
  def irep_node; end
  def key; end
  def key?(*args, &block); end
  def list_of_non_null_items?(type); end
  def namespace(*args, &block); end
  def parent; end
  def parent_type; end
  def path; end
  def query; end
  def received_null_child; end
  def schema; end
  def selection; end
  def spawn(*args, &block); end
  def strategy(*args, &block); end
  def to_h(*args, &block); end
  def type; end
  def value=(new_value); end
  def warden(*args, &block); end
  def wrapped_connection; end
  def wrapped_connection=(arg0); end
  def wrapped_object; end
  def wrapped_object=(arg0); end
  extend Forwardable
  include GraphQL::Query::Context::SharedMethods
  include GraphQL::Tracing::Traceable
end
class GraphQL::Query::Executor
  def execute; end
  def initialize(query); end
  def query; end
  def result; end
end
class GraphQL::Query::Executor::PropagateNull < StandardError
end
class GraphQL::Query::LiteralInput
  def self.coerce(type, ast_node, variables); end
  def self.from_arguments(ast_arguments, argument_owner, variables); end
end
class GraphQL::Query::NullContext
  def initialize; end
  def query; end
  def schema; end
  def self.instance; end
  def self.query(*args, &block); end
  def self.schema(*args, &block); end
  def self.warden(*args, &block); end
  def warden; end
end
class GraphQL::Query::NullContext::NullWarden < GraphQL::Schema::Warden
  def visible?(t); end
  def visible_field?(t); end
  def visible_type?(t); end
end
class GraphQL::Query::Result
  def ==(other); end
  def [](*args, &block); end
  def as_json(*args, &block); end
  def context(*args, &block); end
  def initialize(query:, values:); end
  def inspect; end
  def keys(*args, &block); end
  def method_missing(method_name, *args, &block); end
  def mutation?(*args, &block); end
  def query; end
  def query?(*args, &block); end
  def respond_to_missing?(method_name, include_private = nil); end
  def subscription?(*args, &block); end
  def to_h; end
  def to_json(*args, &block); end
  def values(*args, &block); end
  extend Forwardable
end
class GraphQL::Query::SerialExecution
  def execute(ast_operation, root_type, query_object); end
  def field_resolution; end
  def operation_resolution; end
  def selection_resolution; end
end
module GraphQL::Query::SerialExecution::ValueResolution
  def self.resolve(parent_type, field_defn, field_type, value, selection, query_ctx); end
end
class GraphQL::Query::SerialExecution::FieldResolution
  def arguments; end
  def execution_context; end
  def field; end
  def get_finished_value(raw_value); end
  def get_raw_value; end
  def initialize(selection, parent_type, target, query_ctx); end
  def irep_node; end
  def parent_type; end
  def query; end
  def result; end
  def target; end
end
module GraphQL::Query::SerialExecution::OperationResolution
  def self.resolve(selection, target, query); end
end
module GraphQL::Query::SerialExecution::SelectionResolution
  def self.resolve(target, current_type, selection, query_ctx); end
end
class GraphQL::Query::Variables
  def [](*args, &block); end
  def context; end
  def errors; end
  def fetch(*args, &block); end
  def initialize(ctx, ast_variables, provided_variables); end
  def key?(*args, &block); end
  def length(*args, &block); end
  def to_h(*args, &block); end
  extend Forwardable
end
class GraphQL::Query::InputValidationResult
  def add_problem(explanation, path = nil); end
  def merge_result!(path, inner_result); end
  def problems; end
  def problems=(arg0); end
  def valid?; end
end
class GraphQL::Query::VariableValidationError < GraphQL::ExecutionError
  def initialize(variable_ast, type, value, validation_result); end
  def problem_fields; end
  def to_h; end
  def validation_result; end
  def validation_result=(arg0); end
  def value; end
  def value=(arg0); end
end
class GraphQL::Query::ValidationPipeline
  def analyzers; end
  def build_analyzers(schema, max_depth, max_complexity); end
  def ensure_has_validated; end
  def initialize(query:, validate:, parse_error:, operation_name_error:, max_depth:, max_complexity:); end
  def internal_representation; end
  def max_complexity; end
  def max_depth; end
  def valid?; end
  def validation_errors; end
end
class GraphQL::Query::OperationNameMissingError < GraphQL::ExecutionError
  def initialize(name); end
end
module GraphQL::InternalRepresentation
end
class GraphQL::InternalRepresentation::Document
  def [](key); end
  def each(&block); end
  def fragment_definitions; end
  def initialize; end
  def operation_definitions; end
end
class GraphQL::InternalRepresentation::Node
  def ==(other); end
  def arguments; end
  def ast_node; end
  def ast_nodes; end
  def deep_merge_node(new_parent, scope: nil, merge_self: nil); end
  def definition; end
  def definition_name; end
  def definitions; end
  def get_typed_children(obj_type); end
  def initialize(name:, owner_type:, query:, return_type:, parent:, ast_nodes: nil, definitions: nil); end
  def initialize_copy(other_node); end
  def inspect; end
  def name; end
  def owner_type; end
  def owner_type=(arg0); end
  def parent; end
  def parent=(arg0); end
  def query; end
  def return_type; end
  def scoped_children; end
  def subscription_topic; end
  def typed_children; end
end
module GraphQL::InternalRepresentation::Print
  def print(schema, query_string); end
  def print_node(node, indent: nil); end
  def self.print(schema, query_string); end
  def self.print_node(node, indent: nil); end
end
module GraphQL::InternalRepresentation::Rewrite
  def initialize(*arg0); end
  def on_field(ast_node, ast_parent); end
  def on_fragment_definition(ast_node, parent); end
  def on_fragment_spread(ast_node, ast_parent); end
  def on_inline_fragment(node, parent); end
  def on_operation_definition(ast_node, parent); end
  def operations; end
  def push_root_node(ast_node, definitions); end
  def rewrite_document; end
  def skip?(ast_node); end
  include GraphQL::Language
end
class GraphQL::InternalRepresentation::Scope
  def concrete_types; end
  def each; end
  def enter(other_type_defn); end
  def initialize(query, type_defn); end
end
module GraphQL::InternalRepresentation::Visit
  def each_node(node); end
  def self.each_node(node); end
  def self.visit_each_node(operations, handlers); end
  def visit_each_node(operations, handlers); end
end
module GraphQL::StaticValidation
end
class GraphQL::StaticValidation::Error
  def initialize(message, path: nil, nodes: nil); end
  def locations; end
  def message; end
  def path; end
  def path=(arg0); end
  def to_h; end
end
module GraphQL::StaticValidation::Error::ErrorHelper
  def error(error_message, nodes, context: nil, path: nil, extensions: nil); end
end
module GraphQL::StaticValidation::DefinitionDependencies
  def dependencies; end
  def dependency_map(&block); end
  def initialize(*arg0); end
  def on_document(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_operation_definition(node, prev_node); end
  def resolve_dependencies; end
end
class GraphQL::StaticValidation::DefinitionDependencies::DependencyMap
  def [](definition_node); end
  def cyclical_definitions; end
  def initialize; end
  def unmet_dependencies; end
  def unused_dependencies; end
end
class GraphQL::StaticValidation::DefinitionDependencies::NodeWithPath
  def eql?(*args, &block); end
  def hash(*args, &block); end
  def initialize(node, path); end
  def name(*args, &block); end
  def node; end
  def path; end
  extend Forwardable
end
class GraphQL::StaticValidation::TypeStack
  def argument_definitions; end
  def directive_definitions; end
  def field_definitions; end
  def initialize(schema, visitor); end
  def object_types; end
  def path; end
  def schema; end
end
module GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  def pop(stack, node); end
  def push(stack, node); end
end
module GraphQL::StaticValidation::TypeStack::FragmentDefinitionStrategy
  def push_path_member(stack, node); end
  def self.push_path_member(stack, node); end
  extend GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
end
module GraphQL::StaticValidation::TypeStack::InlineFragmentStrategy
  def push_path_member(stack, node); end
  def self.push_path_member(stack, node); end
  extend GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
end
module GraphQL::StaticValidation::TypeStack::OperationDefinitionStrategy
  def pop(stack, node); end
  def push(stack, node); end
  def self.pop(stack, node); end
  def self.push(stack, node); end
end
module GraphQL::StaticValidation::TypeStack::FieldStrategy
  def pop(stack, node); end
  def push(stack, node); end
  def self.pop(stack, node); end
  def self.push(stack, node); end
end
module GraphQL::StaticValidation::TypeStack::DirectiveStrategy
  def pop(stack, node); end
  def push(stack, node); end
  def self.pop(stack, node); end
  def self.push(stack, node); end
end
module GraphQL::StaticValidation::TypeStack::ArgumentStrategy
  def pop(stack, node); end
  def push(stack, node); end
  def self.pop(stack, node); end
  def self.push(stack, node); end
end
module GraphQL::StaticValidation::TypeStack::FragmentSpreadStrategy
  def pop(stack, node); end
  def push(stack, node); end
  def self.pop(stack, node); end
  def self.push(stack, node); end
end
class GraphQL::StaticValidation::TypeStack::EnterWithStrategy
  def call(node, parent); end
  def initialize(stack, strategy); end
end
class GraphQL::StaticValidation::TypeStack::LeaveWithStrategy
  def call(node, parent); end
  def initialize(stack, strategy); end
end
class GraphQL::StaticValidation::Validator
  def initialize(schema:, rules: nil); end
  def validate(query, validate: nil); end
end
class GraphQL::StaticValidation::ValidationContext
  def argument_definition(*args, &block); end
  def dependencies(*args, &block); end
  def directive_definition(*args, &block); end
  def document(*args, &block); end
  def errors; end
  def field_definition(*args, &block); end
  def fragments(*args, &block); end
  def initialize(query, visitor_class); end
  def object_types(*args, &block); end
  def on_dependency_resolve(&handler); end
  def on_dependency_resolve_handlers; end
  def operations(*args, &block); end
  def parent_type_definition(*args, &block); end
  def path(*args, &block); end
  def query; end
  def schema(*args, &block); end
  def type_definition(*args, &block); end
  def valid_literal?(ast_value, type); end
  def visitor; end
  def warden(*args, &block); end
  extend Forwardable
end
class GraphQL::StaticValidation::LiteralValidator
  def constant_scalar?(ast_value); end
  def ensure_array(value); end
  def initialize(context:); end
  def maybe_raise_if_invalid(ast_value); end
  def present_input_field_values_are_valid(type, ast_node); end
  def required_input_fields_are_present(type, ast_node); end
  def validate(ast_value, type); end
end
class GraphQL::StaticValidation::BaseVisitor < GraphQL::Language::Visitor
  def add_error(error, path: nil); end
  def context; end
  def initialize(document, context); end
  def object_types; end
  def path; end
  def rewrite_document; end
  def self.including_rules(rules, rewrite: nil); end
end
module GraphQL::StaticValidation::BaseVisitor::ContextMethods
  def argument_definition; end
  def directive_definition; end
  def field_definition; end
  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_fragment_with_type(node); end
  def on_inline_fragment(node, parent); end
  def on_input_object(node, parent); end
  def on_operation_definition(node, parent); end
  def parent_type_definition; end
  def type_definition; end
end
class GraphQL::StaticValidation::NoValidateVisitor < GraphQL::StaticValidation::BaseVisitor
  include GraphQL::InternalRepresentation::Rewrite
  include GraphQL::StaticValidation::BaseVisitor::ContextMethods
  include GraphQL::StaticValidation::DefinitionDependencies
end
module GraphQL::StaticValidation::FragmentsAreNamed
  def on_fragment_definition(node, _parent); end
end
class GraphQL::StaticValidation::FieldsAreDefinedOnTypeError < GraphQL::StaticValidation::Error
  def code; end
  def field_name; end
  def initialize(message, type:, field:, path: nil, nodes: nil); end
  def to_h; end
  def type_name; end
end
module GraphQL::StaticValidation::VariablesAreInputTypes
  def get_type_name(ast_type); end
  def on_variable_definition(node, parent); end
end
class GraphQL::StaticValidation::OperationNamesAreValidError < GraphQL::StaticValidation::Error
  def code; end
  def initialize(message, path: nil, nodes: nil, name: nil); end
  def operation_name; end
  def to_h; end
end
class GraphQL::StaticValidation::ArgumentLiteralsAreCompatibleError < GraphQL::StaticValidation::Error
  def argument_name; end
  def code; end
  def initialize(message, type:, path: nil, nodes: nil, argument: nil); end
  def to_h; end
  def type_name; end
end
class GraphQL::StaticValidation::DirectivesAreDefinedError < GraphQL::StaticValidation::Error
  def code; end
  def directive_name; end
  def initialize(message, directive:, path: nil, nodes: nil); end
  def to_h; end
end
module GraphQL::StaticValidation::ArgumentsAreDefined
  def node_type(parent); end
  def on_argument(node, parent); end
  def parent_name(parent, type_defn); end
end
module GraphQL::StaticValidation::FieldsWillMerge
  def compared_fragments_key(frag1, frag2, exclusive); end
  def conflicts_within_selection_set(node, parent_type); end
  def fields_and_fragments_from_selection(node, owner_type:, parents:); end
  def find_conflict(response_key, field1, field2, mutually_exclusive: nil); end
  def find_conflicts_between(response_keys, response_keys2, mutually_exclusive:); end
  def find_conflicts_between_fields_and_fragment(fragment_spread, fields, mutually_exclusive:); end
  def find_conflicts_between_fragments(fragment_spread1, fragment_spread2, mutually_exclusive:); end
  def find_conflicts_between_sub_selection_sets(field1, field2, mutually_exclusive:); end
  def find_conflicts_within(response_keys); end
  def find_fields_and_fragments(selections, owner_type:, parents:, fields:, fragment_spreads:); end
  def initialize(*arg0); end
  def mutually_exclusive?(parents1, parents2); end
  def on_field(node, _parent); end
  def on_operation_definition(node, _parent); end
  def possible_arguments(field1, field2); end
end
class GraphQL::StaticValidation::FieldsWillMerge::Field < Struct
  def definition; end
  def definition=(_); end
  def node; end
  def node=(_); end
  def owner_type; end
  def owner_type=(_); end
  def parents; end
  def parents=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class GraphQL::StaticValidation::FieldsWillMerge::FragmentSpread < Struct
  def name; end
  def name=(_); end
  def parents; end
  def parents=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
module GraphQL::StaticValidation::VariableNamesAreUnique
  def on_operation_definition(node, parent); end
end
class GraphQL::StaticValidation::FieldsHaveAppropriateSelectionsError < GraphQL::StaticValidation::Error
  def code; end
  def initialize(message, node_name:, path: nil, nodes: nil, type: nil); end
  def node_name; end
  def to_h; end
  def type_name; end
end
class GraphQL::StaticValidation::RequiredArgumentsArePresentError < GraphQL::StaticValidation::Error
  def arguments; end
  def class_name; end
  def code; end
  def initialize(message, class_name:, name:, arguments:, path: nil, nodes: nil); end
  def name; end
  def to_h; end
end
module GraphQL::StaticValidation::UniqueDirectivesPerLocation
  def on_enum_type_definition(node, parent); end
  def on_enum_value_definition(node, parent); end
  def on_field(node, parent); end
  def on_field_definition(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_value_definition(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_operation_definition(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_union_type_definition(node, parent); end
  def validate_directive_location(node); end
end
module GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  def get_parent_type(context, parent); end
  def on_input_object(node, parent); end
  def validate_input_object(ast_node, context, parent); end
end
class GraphQL::StaticValidation::UniqueDirectivesPerLocationError < GraphQL::StaticValidation::Error
  def code; end
  def directive_name; end
  def initialize(message, directive:, path: nil, nodes: nil); end
  def to_h; end
end
module GraphQL::StaticValidation::FragmentsAreFinite
  def on_document(_n, _p); end
end
module GraphQL::StaticValidation::MutationRootExists
  def on_operation_definition(node, _parent); end
end
class GraphQL::StaticValidation::SubscriptionRootExistsError < GraphQL::StaticValidation::Error
  def code; end
  def initialize(message, path: nil, nodes: nil); end
  def to_h; end
end
class GraphQL::StaticValidation::DirectivesAreInValidLocationsError < GraphQL::StaticValidation::Error
  def code; end
  def initialize(message, target:, path: nil, nodes: nil, name: nil); end
  def name; end
  def target_name; end
  def to_h; end
end
module GraphQL::StaticValidation::VariableUsagesAreAllowed
  def create_error(error_message, var_type, ast_var, arg_defn, arg_node); end
  def depth_of_array(array); end
  def initialize(*arg0); end
  def list_dimension(type); end
  def non_null_levels_match(arg_type, var_type); end
  def on_argument(node, parent); end
  def on_operation_definition(node, parent); end
  def validate_usage(arguments, arg_node, ast_var); end
  def wrap_var_type_with_depth_of_arg(var_type, arg_node); end
end
class GraphQL::StaticValidation::FragmentsAreUsedError < GraphQL::StaticValidation::Error
  def code; end
  def fragment_name; end
  def initialize(message, fragment:, path: nil, nodes: nil); end
  def to_h; end
end
module GraphQL::StaticValidation::FragmentTypesExist
  def on_fragment_definition(node, _parent); end
  def on_inline_fragment(node, _parent); end
  def validate_type_exists(fragment_node); end
end
module GraphQL::StaticValidation::FragmentNamesAreUnique
  def initialize(*arg0); end
  def on_document(_n, _p); end
  def on_fragment_definition(node, parent); end
end
class GraphQL::StaticValidation::FragmentSpreadsArePossibleError < GraphQL::StaticValidation::Error
  def code; end
  def fragment_name; end
  def initialize(message, type:, fragment_name:, parent:, path: nil, nodes: nil); end
  def parent_name; end
  def to_h; end
  def type_name; end
end
class GraphQL::StaticValidation::ArgumentsAreDefinedError < GraphQL::StaticValidation::Error
  def argument_name; end
  def code; end
  def initialize(message, name:, type:, argument:, path: nil, nodes: nil); end
  def name; end
  def to_h; end
  def type_name; end
end
class GraphQL::StaticValidation::VariablesAreUsedAndDefinedError < GraphQL::StaticValidation::Error
  def code; end
  def initialize(message, name:, error_type:, path: nil, nodes: nil); end
  def to_h; end
  def variable_name; end
  def violation; end
end
class GraphQL::StaticValidation::FragmentTypesExistError < GraphQL::StaticValidation::Error
  def code; end
  def initialize(message, type:, path: nil, nodes: nil); end
  def to_h; end
  def type_name; end
end
class GraphQL::StaticValidation::NoDefinitionsArePresentError < GraphQL::StaticValidation::Error
  def code; end
  def initialize(message, path: nil, nodes: nil); end
  def to_h; end
end
class GraphQL::StaticValidation::RequiredInputObjectAttributesArePresentError < GraphQL::StaticValidation::Error
  def argument_name; end
  def argument_type; end
  def code; end
  def initialize(message, path:, nodes:, argument_type:, argument_name:, input_object_type:); end
  def input_object_type; end
  def to_h; end
end
class GraphQL::StaticValidation::VariablesAreInputTypesError < GraphQL::StaticValidation::Error
  def code; end
  def initialize(message, type:, name:, path: nil, nodes: nil); end
  def to_h; end
  def type_name; end
  def variable_name; end
end
module GraphQL::StaticValidation::OperationNamesAreValid
  def initialize(*arg0); end
  def on_document(node, parent); end
  def on_operation_definition(node, parent); end
end
module GraphQL::StaticValidation::DirectivesAreInValidLocations
  def assert_includes_location(directive_defn, directive_ast, required_location); end
  def on_directive(node, parent); end
  def validate_location(ast_directive, ast_parent, directives); end
  include GraphQL::Language
end
module GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  def on_fragment_definition(node, parent); end
  def on_inline_fragment(node, parent); end
  def validate_type_is_composite(node); end
end
module GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  def on_variable_definition(node, parent); end
end
module GraphQL::StaticValidation::VariablesAreUsedAndDefined
  def create_errors(node_variables); end
  def follow_spreads(node, parent_variables, spreads_for_context, fragment_definitions, visited_fragments); end
  def initialize(*arg0); end
  def on_document(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_operation_definition(node, parent); end
  def on_variable_identifier(node, parent); end
end
class GraphQL::StaticValidation::VariablesAreUsedAndDefined::VariableUsage
  def ast_node; end
  def ast_node=(arg0); end
  def declared?; end
  def declared_by; end
  def declared_by=(arg0); end
  def path; end
  def path=(arg0); end
  def used?; end
  def used_by; end
  def used_by=(arg0); end
end
module GraphQL::StaticValidation::DirectivesAreDefined
  def initialize(*arg0); end
  def on_directive(node, parent); end
end
module GraphQL::StaticValidation::FieldsAreDefinedOnType
  def on_field(node, parent); end
end
module GraphQL::StaticValidation::FragmentsAreUsed
  def on_document(node, parent); end
end
module GraphQL::StaticValidation::NoDefinitionsArePresent
  def initialize(*arg0); end
  def on_directive_definition(node, parent); end
  def on_document(node, parent); end
  def on_enum_type_definition(node, parent); end
  def on_enum_type_extension(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_object_type_extension(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_interface_type_extension(node, parent); end
  def on_invalid_node(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_object_type_extension(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_scalar_type_extension(node, parent); end
  def on_schema_definition(node, parent); end
  def on_schema_extension(node, parent); end
  def on_union_type_definition(node, parent); end
  def on_union_type_extension(node, parent); end
  include GraphQL::StaticValidation::Error::ErrorHelper
end
class GraphQL::StaticValidation::MutationRootExistsError < GraphQL::StaticValidation::Error
  def code; end
  def initialize(message, path: nil, nodes: nil); end
  def to_h; end
end
class GraphQL::StaticValidation::ArgumentNamesAreUniqueError < GraphQL::StaticValidation::Error
  def code; end
  def initialize(message, name:, path: nil, nodes: nil); end
  def name; end
  def to_h; end
end
class GraphQL::StaticValidation::FragmentsAreOnCompositeTypesError < GraphQL::StaticValidation::Error
  def argument_name; end
  def code; end
  def initialize(message, type:, path: nil, nodes: nil); end
  def to_h; end
  def type_name; end
end
class GraphQL::StaticValidation::FragmentsAreFiniteError < GraphQL::StaticValidation::Error
  def code; end
  def fragment_name; end
  def initialize(message, name:, path: nil, nodes: nil); end
  def to_h; end
end
class GraphQL::StaticValidation::FragmentNamesAreUniqueError < GraphQL::StaticValidation::Error
  def code; end
  def fragment_name; end
  def initialize(message, name:, path: nil, nodes: nil); end
  def to_h; end
end
class GraphQL::StaticValidation::VariableUsagesAreAllowedError < GraphQL::StaticValidation::Error
  def argument_name; end
  def code; end
  def error_message; end
  def initialize(message, type:, name:, argument:, error:, path: nil, nodes: nil); end
  def to_h; end
  def type_name; end
  def variable_name; end
end
module GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  def node_type(parent); end
  def on_argument(node, parent); end
  def parent_name(parent, type_defn); end
end
class GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTypedError < GraphQL::StaticValidation::Error
  def code; end
  def initialize(message, name:, error_type:, path: nil, nodes: nil, type: nil); end
  def to_h; end
  def type_name; end
  def variable_name; end
  def violation; end
end
class GraphQL::StaticValidation::FragmentsAreNamedError < GraphQL::StaticValidation::Error
  def code; end
  def initialize(message, path: nil, nodes: nil); end
  def to_h; end
end
module GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  def on_field(node, parent); end
  def on_operation_definition(node, _parent); end
  def validate_field_selections(ast_node, resolved_type); end
  include GraphQL::StaticValidation::Error::ErrorHelper
end
module GraphQL::StaticValidation::SubscriptionRootExists
  def on_operation_definition(node, _parent); end
end
module GraphQL::StaticValidation::FragmentSpreadsArePossible
  def initialize(*arg0); end
  def on_document(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def validate_fragment_in_scope(parent_type, child_type, node, context, path); end
end
class GraphQL::StaticValidation::FragmentSpreadsArePossible::FragmentSpread
  def initialize(node:, parent_type:, path:); end
  def node; end
  def parent_type; end
  def path; end
end
module GraphQL::StaticValidation::ArgumentNamesAreUnique
  def on_directive(node, parent); end
  def on_field(node, parent); end
  def validate_arguments(node); end
  include GraphQL::StaticValidation::Error::ErrorHelper
end
class GraphQL::StaticValidation::FieldsWillMergeError < GraphQL::StaticValidation::Error
  def code; end
  def conflicts; end
  def field_name; end
  def initialize(message, field_name:, conflicts:, path: nil, nodes: nil); end
  def to_h; end
end
class GraphQL::StaticValidation::VariableNamesAreUniqueError < GraphQL::StaticValidation::Error
  def code; end
  def initialize(message, name:, path: nil, nodes: nil); end
  def to_h; end
  def variable_name; end
end
module GraphQL::StaticValidation::RequiredArgumentsArePresent
  def assert_required_args(ast_node, defn); end
  def on_directive(node, _parent); end
  def on_field(node, _parent); end
end
class GraphQL::StaticValidation::DefaultVisitor < GraphQL::StaticValidation::BaseVisitor
  include GraphQL::InternalRepresentation::Rewrite
  include GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include GraphQL::StaticValidation::ArgumentNamesAreUnique
  include GraphQL::StaticValidation::ArgumentsAreDefined
  include GraphQL::StaticValidation::BaseVisitor::ContextMethods
  include GraphQL::StaticValidation::DefinitionDependencies
  include GraphQL::StaticValidation::DirectivesAreDefined
  include GraphQL::StaticValidation::DirectivesAreInValidLocations
  include GraphQL::StaticValidation::FieldsAreDefinedOnType
  include GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include GraphQL::StaticValidation::FieldsWillMerge
  include GraphQL::StaticValidation::FragmentNamesAreUnique
  include GraphQL::StaticValidation::FragmentSpreadsArePossible
  include GraphQL::StaticValidation::FragmentTypesExist
  include GraphQL::StaticValidation::FragmentsAreFinite
  include GraphQL::StaticValidation::FragmentsAreNamed
  include GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include GraphQL::StaticValidation::FragmentsAreUsed
  include GraphQL::StaticValidation::MutationRootExists
  include GraphQL::StaticValidation::NoDefinitionsArePresent
  include GraphQL::StaticValidation::OperationNamesAreValid
  include GraphQL::StaticValidation::RequiredArgumentsArePresent
  include GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include GraphQL::StaticValidation::SubscriptionRootExists
  include GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include GraphQL::StaticValidation::VariableNamesAreUnique
  include GraphQL::StaticValidation::VariableUsagesAreAllowed
  include GraphQL::StaticValidation::VariablesAreInputTypes
  include GraphQL::StaticValidation::VariablesAreUsedAndDefined
end
class GraphQL::StaticValidation::InterpreterVisitor < GraphQL::StaticValidation::BaseVisitor
  include GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include GraphQL::StaticValidation::ArgumentNamesAreUnique
  include GraphQL::StaticValidation::ArgumentsAreDefined
  include GraphQL::StaticValidation::BaseVisitor::ContextMethods
  include GraphQL::StaticValidation::DefinitionDependencies
  include GraphQL::StaticValidation::DirectivesAreDefined
  include GraphQL::StaticValidation::DirectivesAreInValidLocations
  include GraphQL::StaticValidation::FieldsAreDefinedOnType
  include GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include GraphQL::StaticValidation::FieldsWillMerge
  include GraphQL::StaticValidation::FragmentNamesAreUnique
  include GraphQL::StaticValidation::FragmentSpreadsArePossible
  include GraphQL::StaticValidation::FragmentTypesExist
  include GraphQL::StaticValidation::FragmentsAreFinite
  include GraphQL::StaticValidation::FragmentsAreNamed
  include GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include GraphQL::StaticValidation::FragmentsAreUsed
  include GraphQL::StaticValidation::MutationRootExists
  include GraphQL::StaticValidation::NoDefinitionsArePresent
  include GraphQL::StaticValidation::OperationNamesAreValid
  include GraphQL::StaticValidation::RequiredArgumentsArePresent
  include GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include GraphQL::StaticValidation::SubscriptionRootExists
  include GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include GraphQL::StaticValidation::VariableNamesAreUnique
  include GraphQL::StaticValidation::VariableUsagesAreAllowed
  include GraphQL::StaticValidation::VariablesAreInputTypes
  include GraphQL::StaticValidation::VariablesAreUsedAndDefined
end
module GraphQL::Compatibility
end
module GraphQL::Compatibility::ExecutionSpecification
  def self.build_suite(execution_strategy); end
end
module GraphQL::Compatibility::ExecutionSpecification::CounterSchema
  def self.build(execution_strategy); end
end
module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema
  def self.build(execution_strategy); end
end
class GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::CustomCollection
  def each; end
  def initialize(storage); end
end
module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::TestMiddleware
  def self.call(parent_type, parent_object, field_definition, field_args, query_context, &next_middleware); end
end
module GraphQL::Compatibility::LazyExecutionSpecification
  def self.build_suite(execution_strategy); end
end
module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema
  def self.build(execution_strategy); end
end
class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPush
  def initialize(ctx, value); end
  def push; end
  def value; end
end
class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPushCollection
  def initialize(ctx, values); end
  def push; end
  def value; end
end
module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyInstrumentation
  def self.instrument(type, field); end
end
module GraphQL::Compatibility::QueryParserSpecification
  def self.build_suite(&block); end
end
module GraphQL::Compatibility::QueryParserSpecification::QueryAssertions
  def assert_valid_directive(directive); end
  def assert_valid_field(field); end
  def assert_valid_fragment(fragment_def); end
  def assert_valid_fragment_spread(fragment_spread); end
  def assert_valid_literal_argument(argument); end
  def assert_valid_query(query); end
  def assert_valid_typed_inline_fragment(inline_fragment); end
  def assert_valid_typeless_inline_fragment(inline_fragment); end
  def assert_valid_variable(variable); end
  def assert_valid_variable_argument(argument); end
end
module GraphQL::Compatibility::QueryParserSpecification::ParseErrorSpecification
  def assert_empty_document(query_string); end
  def assert_raises_parse_error(query_string); end
  def assert_rejects_character(char); end
  def test_it_includes_line_and_column; end
  def test_it_parses_blank_queries; end
  def test_it_rejects_bad_unicode; end
  def test_it_rejects_empty_inline_fragments; end
  def test_it_rejects_invalid_characters; end
  def test_it_rejects_unexpected_ends; end
  def test_it_rejects_unterminated_strings; end
  def test_it_restricts_on; end
end
module GraphQL::Compatibility::SchemaParserSpecification
  def self.build_suite(&block); end
end
class GraphQL::Function
  def arguments; end
  def call(obj, args, ctx); end
  def complexity; end
  def deprecation_reason; end
  def description; end
  def self.argument(*args, **kwargs, &block); end
  def self.arguments; end
  def self.build_field(function); end
  def self.complexity(new_value = nil); end
  def self.deprecation_reason(new_value = nil); end
  def self.description(new_value = nil); end
  def self.own_arguments; end
  def self.parent_function?; end
  def self.type(premade_type = nil, &block); end
  def self.types; end
  def type; end
end
class GraphQL::Filter
  def call(member, ctx); end
  def initialize(only: nil, except: nil); end
  def merge(only: nil, except: nil); end
end
class GraphQL::Filter::MergedOnly
  def call(member, ctx); end
  def initialize(first, second); end
  def self.build(onlies); end
end
class GraphQL::Filter::MergedExcept < GraphQL::Filter::MergedOnly
  def call(member, ctx); end
end
class GraphQL::Subscriptions
  def build_id; end
  def delete_subscription(subscription_id); end
  def deliver(subscription_id, result); end
  def each_subscription_id(event); end
  def execute(subscription_id, event, object); end
  def execute_all(event, object); end
  def initialize(schema:, **rest); end
  def normalize_arguments(event_name, arg_owner, args); end
  def normalize_name(event_or_arg_name); end
  def read_subscription(subscription_id); end
  def self.use(defn, options = nil); end
  def trigger(event_name, args, object, scope: nil); end
  def write_subscription(query, events); end
end
class GraphQL::Subscriptions::Event
  def arguments; end
  def context; end
  def initialize(name:, arguments:, field: nil, context: nil, scope: nil); end
  def name; end
  def self.serialize(name, arguments, field, scope:); end
  def self.stringify_args(args); end
  def topic; end
end
class GraphQL::Subscriptions::Instrumentation
  def after_query(query); end
  def before_query(query); end
  def initialize(schema:); end
  def instrument(type, field); end
end
class GraphQL::Subscriptions::Instrumentation::SubscriptionRegistrationResolve
  def call(obj, args, ctx); end
  def initialize(inner_proc); end
end
module GraphQL::Subscriptions::Serialize
  def dump(obj); end
  def dump_recursive(obj); end
  def load(str); end
  def self.dump(obj); end
  def self.dump_recursive(obj); end
  def self.dump_value(obj); end
  def self.load(str); end
  def self.load_value(value); end
end
module GraphQL::Subscriptions::SubscriptionRoot
  def field(*args, extensions: nil, **rest, &block); end
  def self.extended(child_cls); end
end
module GraphQL::Subscriptions::SubscriptionRoot::InstanceMethods
  def skip_subscription_root(*arg0); end
end
class GraphQL::Subscriptions::SubscriptionRoot::Extension < GraphQL::Schema::FieldExtension
  def after_resolve(value:, context:, object:, arguments:, **rest); end
end
class GraphQL::Subscriptions::InvalidTriggerError < GraphQL::Error
end
class GraphQL::ParseError < GraphQL::Error
  def col; end
  def initialize(message, line, col, query, filename: nil); end
  def line; end
  def query; end
  def to_h; end
end
class GraphQL::Backtrace
  def [](*args, &block); end
  def each(*args, &block); end
  def initialize(context, value: nil); end
  def inspect; end
  def self.disable; end
  def self.enable; end
  def self.use(schema_defn); end
  def to_a; end
  def to_s; end
  extend Forwardable
  include Enumerable
end
module GraphQL::Backtrace::InspectResult
  def inspect_result(obj); end
  def inspect_truncated(obj); end
  def self.inspect_result(obj); end
  def self.inspect_truncated(obj); end
end
class GraphQL::Backtrace::Table
  def build_rows(context_entry, rows:, top: nil); end
  def initialize(context, value:); end
  def render_table(rows); end
  def rows; end
  def to_backtrace; end
  def to_table; end
end
class GraphQL::Backtrace::TracedError < GraphQL::Error
  def context; end
  def graphql_backtrace; end
  def initialize(err, current_ctx); end
end
module GraphQL::Backtrace::Tracer
  def self.trace(key, metadata); end
  def trace(key, metadata); end
end
module GraphQL::DeprecatedDSL
  def self.activate; end
end
module GraphQL::DeprecatedDSL::Methods
  def !; end
end
module GraphQL::Authorization
end
class GraphQL::Authorization::InaccessibleFieldsError < GraphQL::AnalysisError
  def context; end
  def fields; end
  def initialize(fields:, irep_nodes:, context:); end
  def irep_nodes; end
end
module GraphQL::Authorization::Analyzer
  def call(memo, visit_type, irep_node); end
  def final_value(memo); end
  def initial_value(query); end
  def self.call(memo, visit_type, irep_node); end
  def self.final_value(memo); end
  def self.initial_value(query); end
end
class GraphQL::UnauthorizedError < GraphQL::Error
  def context; end
  def initialize(message = nil, object: nil, type: nil, context: nil); end
  def object; end
  def type; end
end
class GraphQL::UnauthorizedFieldError < GraphQL::UnauthorizedError
  def field; end
  def field=(arg0); end
  def initialize(message = nil, object: nil, type: nil, context: nil, field: nil); end
end
class GraphQL::LoadApplicationObjectFailedError < GraphQL::ExecutionError
  def argument; end
  def id; end
  def initialize(argument:, id:, object:); end
  def object; end
end
class GraphQL::Error < StandardError
end
module GraphQL::StringDedupBackport
end
